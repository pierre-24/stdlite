title: Public API documentation
description: |
  This section describes the public API of `libstdlite`.
  
  {% include-markdown "../includes/API.md" %}

output: docs/API
files:
  - "include/*.h"
  - "include/**/*.h"
groups:
  - name: basis
    title: Basis set
    description: |
      Describe a set of basis functions, centered on atoms.
      
      ```c
      #include <stdlite/basis.h>
      ```
      
      Follows the structure of [`libcint`](https://github.com/sunqm/libcint/blob/master/doc/program_ref.txt), so that it can be used to compute extra integrals.
      
      !!! note
          
          Most of the documentation (and all examples) of libcint actually refers to the old (version < 3.0) API.
          The new API actually includes two extra parameters [described there](https://github.com/sunqm/libcint/blob/master/doc/program_ref.tex#L228).
  - name: errors
    title: Error definition and handling
    description: |
      Handling of errors and error messages.
      
      ```c
      #include <stdlite/errors.h>
      ```
      
      Also contains function to signal warnings and debug messages.
      
      By default `DEBUG_LVL=1`, which allows errors and warnings to be printed. 
      To shut down every messages, use `stdl_set_debug_level(-1)`.
  - name: helpers
    title: Helpers functions and macros
    description: |
      Helpers functions and macros.
      
      ```c
      #include <stdlite/helpers.h>
      ```
  - name: matrix
    title: Matrices
    description: |
      Utilities to work with matrices.
      
      ```c
      #include <stdlite/matrix.h>
      ```
  - name: wavefunction
    title: Wavefunction results
    description: |
      Store the result of a QC calculation, which is the input for subsequent (s)TD-DFT calculations.
      
      ```c
      #include <stdlite/wavefunction.h>
      ```
  - name: utilities
    title: Utilities
    description: Utility functions, not directly required to use the library.
    groups:
      - name: lexer
        title: Lexer
        description: |
          A character per character lexer, that assign types to certain kind of characters.
      
          ```c
          #include <stdlite/utils/lexer.h>
          ```
      - name: base_parser
        title: Basic parser utilities
        description: |
          Basic parser utilities to extract strings, integers, and real numbers from files.
          
          ```c
          #include <stdlite/utils/base_parser.h>
          ```
      - name: fchk_parser
        title: FCHK parser
        description: |
          Parser for the FCHK files generated by Gaussian.
          FCHK stands for *formatted checkpoint*, for which the format is described in the "FChk File" tab of [this page](https://gaussian.com/interfacing/).
          
          ```c
          #include <stdlite/utils/fchk_parser.h>
          ```
          
          While this parser contains a few safeguards, it works better if the FCHK is correctly formatted.
          
          !!! warning
          
              The logical type, `L`, is not implemented. However, it does not seems to be used in production FCHK.
              Scalar `C` is also not implemented nor used.
          
          In order to parse a FCHK, use something of the form:
          
          ```c
          char* name = NULL;
          char type;
          int error, is_scalar;
          
          // 1. Open file, create lexer
          FILE* f = fopen("file.fchk", "r");
          stdl_lexer* lx = stdl_lexer_new(f);
          
          // 2. Skip intro
          stdl_fchk_parser_skip_intro(lx);
          
          // 3. Read sections
          while (lx->current_tk_type != STDL_TK_EOF) {
            // read section info, giving:
            // a) the name of the section, b) its type, and c) if it is a scalar
            error = stdl_fchk_parser_get_section_info(lx, &name, &type, &is_scalar);
            
            if(error == STDL_ERR_OK) {
              if(strcmp("an interesting section", name) == 0) {
                /* Read the content of this section by using either:
                 * - `stdl_fchk_parser_get_scalar_*()`, or
                 * - `stdl_fchk_parser_get_vector_*()`.
                 * Don't forget to free the result after use.
                 */
              } else if(/* ... */) {
                /* ... */
              } else {
                // not interesting, skip section
                stdl_fchk_parser_skip_section(lx, type, is_scalar);
              }
              free(name);
            }
          }
      
          stdl_lexer_delete(lx);
          fclose(f);
          ```