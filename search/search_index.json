{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>stdlite</code>","text":"<p>An attempt at creating a lightweight library to perform sTD-DFT calculations.</p> <p>If you are not familiar with the sTD-DFT theory of Grimme and co-workers, it is explained in the next page.</p> <p>Then, if you want to run a sTD-DFT calculation, you can compile and install <code>stdlite_run</code>, a standalone program that uses the <code>stdlite</code> library developed for this project. A tutorial as well as a complete description of its inputs is provided.</p>"},{"location":"#what","title":"What?","text":"<p>My Ph.D. was mainly dedicated to nonlinear optics (in particular the first and second hyperpolarizability) and during a collaboration with Prof. M. de Wergifossse, I discovered the simplified approaches developed by Prof S. Grimme. Among other, we computed the first hyperpolarizability of a whole protein with almost 4000 atoms, in good agreement with experimental data (see 10.1021/acs.jpclett.1c02911).</p> <p>The sTDA/sTD-DFT approaches are mainly implement in <code>stda</code>. However, its integration with other quantum chemistry programs is not straightforward. Following the example of <code>tblite</code>, I thus decided to develop a standalone library.</p> <p>Contributions are welcomed, as described on this page.</p>"},{"location":"#how","title":"How","text":"<p>Rather than Fortran, this library is developed in C, with libcint (used by pycsf) to evaluate the integrals. </p>"},{"location":"#who","title":"Who?","text":"<p>My name is Pierre Beaujean, and I'm a Ph.D. in quantum chemistry from the University of Namur (Belgium). While now working on batteries, I still continue to look into nonlinear optics in collaboration with other people of my lab... And beyond. It is also a good opportunity to improve my skills.</p>"},{"location":"app/","title":"<code>stdlite_run</code>","text":"<p>This page describe in details the usage of <code>stdlite_run</code>.</p>"},{"location":"app/#calling-stlite_run","title":"Calling <code>stlite_run</code>","text":"<p>The utility <code>stdlite_run</code> primarily read an input file written in the TOML format, described below.</p> <p>A typical way to call the utility is to use:</p> <pre><code>stdlite_run input.toml\n</code></pre> <p>Command line options, described below can also be given:</p> <pre><code>stdlite_run input.toml --ctx_ax=\"0.7\"\n</code></pre> <p>Note that a command line option, when it exists, have precedence over the input file.</p>"},{"location":"app/#environment-variables","title":"Environment variables","text":"<p>If the application is built to do so (which is the default), one can control the number of processors used by OpenMP to accelerate the program:</p> <pre><code>export OMP_NUM_THREADS=4\n</code></pre> <p>Eventually, the verbosity level can be adjusted through environment variables:</p> <pre><code>export STDL_LOG_LEVEL=1 # default is 0, set to -1 to silence the program\nexport STDL_DEBUG_LEVEL=3 # default is 1, set to -1 to silence the program\n</code></pre>"},{"location":"app/#inputs","title":"Inputs","text":"<p>In the following, \"Keyword\" refers to keywords that can be put in the TOML input.</p> <p>When a keyword type is \"<code>str</code>/<code>float</code> (energy)\", the energy is to be given in the format <code>\"xxxYY\"</code>, where <code>xxx</code> is a number, and <code>YY</code> is a unit. Currently, 3 units are supported: <code>au</code> (atomic units), <code>eV</code> (electronvolts), and <code>nm</code> (nanometers). If no unit are given, atomic units are assumed. Valid inputs are, e.g., <code>\"8.5eV\"</code>, <code>\"1200nm\"</code>, <code>\"0.25au\"</code>, <code>1.25</code>, etc.</p>"},{"location":"app/#general","title":"General","text":"<p>Title</p> <p>Type: <code>str</code> Keyword: <code>title</code> Default: None</p> <p>Title of the calculation, in free format. It is there for documentation/archiving purposes, and will never be parsed.</p> <p>Output</p> <p>Type: <code>str</code> (path) Keyword: <code>data_output</code> Command line option: <code>--data_output</code> Default: <code>\"stdlite_calculation.h5\"</code></p> <p>Path where the data of the calculation will be stored, in HDF5.</p>"},{"location":"app/#context-context","title":"Context (<code>[context]</code>)","text":"<p>These are the keywords related to the creation of the context, i.e., the selection of the CSFs and the creation of the \\(\\mathbf A'\\) and \\(\\mathbf B'\\) super-matrices. </p> <p>Source</p> <p>Type: <code>str</code> (path) Keyword: <code>source</code> Command line option: <code>--ctx_source</code></p> <p>Path to a QM file containing at least a wavefunction and a corresponding basis set.  This is the only mandatory keyword.</p> <p>Source type</p> <p>Type: <code>str</code> Keyword: <code>source_type</code> Command line option: <code>--ctx_source_type</code> Default: <code>\"FCHK\"</code></p> <p>Type of source. Currently the possible values are:</p> <ul> <li><code>\"MOLDEN\"</code> (Molden file), </li> <li><code>\"FCHK\"</code> (Gaussian FCHK), </li> <li><code>\"STDL_CTX\"</code> (context from a previous calculation), and </li> <li><code>\"STDL_CTX_WB\"</code> (context from a previous calculation, but only the wavefunction and basis are used).</li> </ul> <p>Note that <code>\"STDL_CTX\"</code> implies that exactly the same context, i.e., the same CSFs and the same \\(\\mathbf A'\\) and \\(\\mathbf B'\\) super-matrices are used, so it totally skips the context creation. If you want to re-create a new context, use <code>\"STDL_CTX_WB\"</code>.</p> <p>Energy threshold</p> <p>Type: <code>str</code>/<code>float</code> (energy) Keyword: <code>ethr</code> Command line option: <code>--ctx_ethr</code> Default: <code>\"7eV\"</code></p> <p>Energy threshold for the truncation of the CI space.</p> <p>Perturbation energy threshold</p> <p>Type: <code>str</code>/<code>float</code> (energy) Keyword: <code>e2thr</code> Command line option: <code>--ctx_e2thr</code> Default: <code>\"1e-4au\"</code></p> <p>Perturbation energy threshold for the selection of secondary CSFs in the truncation of the CI space.</p> <p>Method for the creation of context</p> <p>Type: <code>str</code> Keyword: <code>method</code> Command line option: <code>--ctx_method</code> Default: <code>\"monopole\"</code></p> <p>Method for the calculation of the elements of the  \\(\\mathbf A'\\) and \\(\\mathbf B'\\) super-matrices.  Currently the possible values are:</p> <ul> <li><code>\"monopole\"</code> (default sTD-DFT procedure, i.e., the monopole approximation), </li> <li><code>\"monopole_direct\"</code> (same as default, but the integrals are evaluated on demand).</li> </ul> <p>The <code>\"xxx_direct\"</code> version requires less memory.</p> <p>Tamm-Dancoff approximation</p> <p>Type: <code>int</code> Keyword: <code>tda</code> Command line option: <code>--ctx_tda</code> Default: <code>1</code></p> <p>If different from 0, use the Tamm-Dancoff approximation.</p> <p>Parameter for Coulomb integrals</p> <p>Type: <code>float</code> Keyword: <code>gammaJ</code> Command line option: <code>--ctx_gammaJ</code> Default: <code>4.0</code></p> <p>Parameters for the Coulomb integral, \\(\\gamma_J\\), in the monopole approximation.</p> <p>Parameter for exchange integrals</p> <p>Type: <code>float</code> Keyword: <code>gammaK</code> Command line option: <code>--ctx_gammaK</code> Default: <code>2.0</code></p> <p>Parameters for the exchange integral, \\(\\gamma_K\\), in the monopole approximation.</p> <p>Hartree-Fock exchange percentage</p> <p>Type: <code>float</code> Keyword: <code>ax</code> Command line option: <code>--ctx_ax</code> Default: <code>0.5</code></p> <p>Assuming a global hybrid, amount of Hartree-Fock exchange, between 0 and 1.</p>"},{"location":"app/#responses-responses","title":"Responses (<code>[responses]</code>)","text":"<p>These are the keywords related to the calculation of responses, their residues, and the related properties.</p> <p>In the following, <code>wX</code> is a frequency, thus following the syntax for energy mentioned in the preamble. <code>opX</code> is an operator, which should be one of:</p> <ul> <li><code>\"dipl\"</code>: dipole length operator;</li> </ul> <p>Other operators will be added in the future.</p> <p>Linear reponses</p> <p>Type: <code>list</code> Keyword: <code>linear</code> Default: <code>[]</code></p> <p>List the linear reponses to compute.  Each linear response \\(\\braket{\\braket{\\hat A;\\hat B}}_\\omega\\) is to be given as: <code>{opA = \"A\", opB = \"B\", wB=\"w\"}</code>.</p> <p>For example, the following input will compute the electric polarizability at 512 and 1064nm:</p> <pre><code>[responses]\nlinear = [\n    {opA = 'dipl', opB = 'dipl', wB = '512nm'}\n    {opA = 'dipl', opB = 'dipl', wB = '1064nm'}, \n]\n</code></pre> <p>Single residue of the linear response</p> <p>Type: <code>list</code> Keyword: <code>linear_sr</code> Default: <code>[]</code></p> <p>List the ground-to-excited states properties to compute. Each request for \\(\\braket{0|\\hat A|m}\\) is to be given as: <code>{opA = \"A\", root = N}</code>. <code>N</code> is the number of excited states, <code>\\ket{m}</code>, to consider. If <code>N</code> &lt; 0, all possible excited states (i.e., corresponding to the number of CSFs) are computed.</p> <p>For example, the following input will compute the transition dipole moments for the 15 first excited states:</p> <pre><code>[responses]\nlinear_sr = [\n    {opA = 'dipl', root = 15}\n]\n</code></pre> <p>Quadratic responses</p> <p>Type: <code>list</code> Keyword: <code>quadratic</code> Default: <code>[]</code></p> <p>List the quadratic reponses to compute.  Each quadratic response \\(\\braket{\\braket{\\hat A;\\hat B, \\hat C}}_{\\omega_1,\\omega_2}\\) is to be given as: <code>{opA = \"A\", opB = \"B\", opC = \"C\", wB = \"w1\", wC = \"w2\"}</code>.</p> <p>For example, the following input  will compute the SHG first hyperpolarizability at 1064nm:</p> <pre><code>[responses]\nquadratic = [\n    {opA = 'dipl', opB = 'dipl', opC = 'dipl', wB = '1064nm', wC = '1064nm'}, \n]\n</code></pre>"},{"location":"app/#outputs","title":"Outputs","text":"<p>Log messages are written in <code>stdout</code>, while errors are given in <code>stderr</code>.</p>"},{"location":"app/#data","title":"Data","text":"<p>After run, all data are saved in a HDF5 file (by default, <code>stdlite_calculation.h5</code>).</p> <p>You can re-use the context (e.g., to compute other responses) with:</p> <pre><code>[context]\nsource = \"stdlite_calculation.h5\"\nsource_type = \"STDL_CTX\"\n</code></pre>"},{"location":"build/","title":"Build & install","text":""},{"location":"build/#preparation","title":"Preparation","text":"<p>To build <code>stdlite</code> from its sources, you'll need:</p> <ol> <li>A C compiler. Currently, both GCC and clang are supported.</li> <li>The Meson build system, with a backend (generally ninja). This is probably available in you package manager.</li> <li>A linear algebra backend which provides CBLAS and LAPACKe interfaces for C. Currently, either openblas+netlib Lapack(e) or Intel MKL are supported. To install MKL, which seems to provide better performances, see, e.g., this link. Since LAPACKe is not yet suported by flexiblas, this option is not available at the moment.</li> <li>The HDF5 library (and its headers), which is most probably available in your favorite distribution package manager.</li> </ol> Optional dependencies <p>Optionally, there are some (light-weight) dependencies that are installed by the project if not found, but that you can also install yourself if you prefer.</p> <p>For the library:</p> <ul> <li><code>libcint</code>.</li> </ul> <p>For the tests:</p> <ul> <li><code>Unity</code> (which is a test framework, not the game engine).</li> </ul> <p>For the application:</p> <ul> <li><code>argtable3</code>,</li> <li><code>tomlc99</code>.</li> </ul> <p>Then, make sure that they are available in the corresponding <code>PATH</code>-like variables if needed.</p> <p>Then, download the sources using <code>git</code>:</p> <pre><code>git clone https://github.com/pierre-24/stdlite.git\n</code></pre> <p>or directly on the GitHub repository, as a ZIP.</p>"},{"location":"build/#compilation","title":"Compilation","text":"<p>If you want to use <code>clang</code>, set the <code>CC</code> variable to do so:</p> <pre><code>export CC=clang\n</code></pre> <p>Use the <code>meson</code> subcommands to set up the project.</p> <pre><code># go in folder\ncd stdlite\n\n# Setup the build.\n# It downloads extra dependencies if required. \nmeson setup _build --buildtype=release\n</code></pre> <p>The default build instruction use OpenBLAS and OpenMP. To change this, use: <pre><code># to use MKL (this will probably improve performances)\nmeson configure _build -Dla_backend=mkl\n\n# to disable OpenMP (not recommended)\nmeson configure _build -Dopenmp=false\n</code></pre></p> <p>Then, compile the project:</p> <pre><code>meson compile -C _build\n</code></pre> <p>If you want, you can also run the test suite to check that everything is ok:</p> <pre><code>meson test -C _build\n</code></pre>"},{"location":"build/#installation","title":"Installation","text":"<p>To install the libraries and executables, use:</p> <pre><code># (optional) if you want to change the default installation prefix:\nmeson configure _build --prefix=$HOME/.local\n\n# install\nmeson install -C _build\n</code></pre> <p>Depending on the installation prefix and your user rights, root access might be required to perform this last action.</p>"},{"location":"contributing/","title":"Contribute","text":"<p>Contributions, either with issues or pull requests are welcomed.</p>"},{"location":"contributing/#install","title":"Install","text":"<p>If you want to contribute, this is the usual deal:  start by forking, then clone your fork and install the dependencies using Meson.</p> <p>I personally use Clion for the development, as it is integrated with the Meson build system, but others might do.</p>"},{"location":"contributing/#tips-to-contribute","title":"Tips to contribute","text":"<ul> <li> <p>A good place to start is the list of issues.   In fact, it is easier if you start by filling an issue, and if you want to work on it, says so there, so that everyone knows that the issue is handled.</p> </li> <li> <p>Don't forget to work on a separate branch.   Since this project follow the git flow, you should base your branch on <code>dev</code>, not work in it directly:</p> <pre><code>git checkout -b new_branch origin/dev\n</code></pre> </li> <li> <p>Pull requests should be unitary, and include unit test(s) and documentation if needed.   The test suite must succeed for the merge request to be accepted.</p> </li> <li> <p>If you want to see and edit the doc, you can run the <code>mkdocs</code> webserver:</p> <pre><code>pip install mkdocs mkdocs-material\nmkdocs serve\n</code></pre> <p>Code documentation is generated via doxide, with:</p> <pre><code>doxide build\n</code></pre> </li> </ul>"},{"location":"theory/","title":"Theory","text":""},{"location":"theory/#introduction","title":"Introduction","text":"<p>Molecular properties are defined as a response of a (molecular) system to an external perturbation (change of geometry, application of an external electric field, etc). The goal of <code>stdlite</code> is to compute properties within the simplified TDA/TD-DFT framework.</p> <p>TL;DR:</p> <p>The following steps are required to perform a sTD-DFT calculation:</p> <ol> <li>Extract data (i.e., the atomic orbitals, as well as the MO energies, \\(\\varepsilon\\), and LCAO coefficients, \\(\\mathbf C\\)) from a QC calculation;</li> <li>Select configuration state functions (CSFs, \\(\\ket{\\Psi_i^a}\\), or singly excited determinants) using a set of rules and build the corresponding electronic hessian (super-)matrices \\(\\mathbf A'\\) and \\(\\mathbf B'\\) (might be zero);</li> <li>Using said matrices, compute the linear response or amplitude vectors. This generally requires to compute extra expectation values matrices in MO basis, such as the dipole moment;</li> <li>Use said response/amplitude vectors to compute actual properties.</li> </ol>"},{"location":"theory/#response-function-theory","title":"Response function theory","text":"<p>In the time-independent (or static) case, a general expression for the electronic energy under perturbation is:</p> \\[E(\\{\\kappa_i\\}, \\lambda) = \\Braket{\\Psi(\\{\\kappa_i\\}) | \\hat H(\\lambda) | \\Psi(\\{\\kappa_i\\})},\\] <p>where \\(\\{\\kappa_i\\}\\) are the set of parameters that minimize the energy (e.g., the LCAO coefficients), while \\(\\hat H(\\lambda) = \\hat H_0 + \\lambda \\hat V\\), where \\(\\hat H_0\\) is the electronic Hamiltonian (for which solutions are known) and \\(\\hat V\\) is a perturbation. In the framework of the Rayleigh-Schr\u00f6dinger perturbation theory, \\(E\\) can be expanded in a power series, </p> \\[E= E^{(0)} + \\lambda\\,E^{(1)} + \\lambda^2\\,E^{(2)}+\\ldots,\\] <p>with:</p> \\[E^{(k)} = \\frac{1}{k!}\\,\\left.\\frac{d^k E}{d \\lambda^k}\\right|_{\\lambda=0}.\\] <p>In particular, the first order derivative is:</p> \\[\\begin{aligned} \\frac{d E}{d\\lambda} &amp;= \\frac{\\partial E(\\{\\kappa_i\\},\\lambda)}{\\partial\\lambda} + \\sum_i \\left.\\frac{ \\partial E(\\{\\kappa_i \\}, \\lambda)}{\\partial\\kappa_i}\\right|_{\\lambda=0}\\,\\frac{\\partial\\kappa_i}{\\partial\\lambda} \\\\ &amp;= \\Braket{\\Psi(\\{\\kappa_i \\})|\\frac{\\partial\\hat{H}(\\lambda)}{\\partial \\lambda}|\\Psi(\\{\\kappa_i\\})}, \\end{aligned}\\] <p>which is the Hellman-Feynman theorem, obtained under the assumption that the \\(\\{\\kappa_i\\}\\) were obtained variationaly, given the stationary principle:</p> \\[\\forall\\kappa_i: \\left.\\frac{\\partial E(\\{\\kappa_i \\}, \\lambda)}{\\partial\\kappa_i}\\right|_{\\lambda=0} = 0.\\] <p>The second-order derivative is obtained from differentiating the Hellman-Feynman theorem expression, yielding (under the assumption that the perturbation is linear):</p> \\[\\tag{1}\\frac{d^2 E}{d\\lambda^2} = \\sum_i \\left.\\frac{\\partial^2 E(\\{\\kappa_i\\},\\lambda)}{\\partial\\lambda\\partial\\kappa_i}\\right|_{\\lambda=0}\\,\\frac{\\partial\\kappa_i}{\\partial\\lambda}  \\Leftrightarrow \\braket{\\braket{\\hat V; \\hat V}} = (\\mathbf\\kappa^\\lambda)^T\\,\\eta^\\lambda\\] <p>where \\(\\braket{\\braket{\\hat V; \\hat V}}\\) is the linear response function, \\(\\mathbf\\eta^\\lambda\\) is the perturbed electronic gradient, and \\(\\mathbf\\kappa^\\lambda\\), the first-order response vector to \\(\\lambda\\), containing all \\(\\partial\\kappa_i/\\partial\\lambda\\). \\(\\kappa^\\lambda\\) is computed thanks to the following set of equations (derivative of the stationary condition):</p> \\[\\tag{2}\\sum_j \\left.\\frac{\\partial^2 E(\\{\\kappa_i\\},\\lambda)}{\\partial\\kappa_i\\partial\\kappa_j}\\right|_{\\lambda=0}\\,\\frac{\\partial\\kappa_j}{\\partial\\lambda} = -\\left.\\frac{\\partial^2 E(\\{\\kappa_i\\},\\lambda)}{\\partial\\lambda\\partial\\kappa_i}\\right|_{\\lambda=0}  \\Leftrightarrow \\mathbf{E}^\\lambda\\,\\mathbf\\kappa^\\lambda = -\\mathbf\\eta^\\lambda\\] <p>where \\(\\mathbf E^\\lambda\\) is the electronic Hessian. Evaluating the elements of \\(\\mathbf E^\\lambda\\) and \\(\\mathbf\\eta^\\lambda\\) actually result in new kinds of (bielectronic) integrals to evaluate (vide supra), while \\(\\kappa^\\lambda\\) has to be computed by solving this equation. Thanks to the 2n+1 rule, the response vector can be used to access the quadratic response function (i.e., the third derivative of the energy w.r.t. \\(\\lambda\\)) as well.</p> <p>The dynamic case is similar.  Assuming a time-dependent perturbed Hamiltonian (Heisenberg picture), \\(\\hat H(\\lambda,t) = \\hat H_0 + \\hat V(\\lambda, t)\\), its development is governed by the time-dependent (TD) Shr\u00f6dinger equation. Following the Floquet theory, it is proposed to extract a (position independent) phase factor, \\(F(t)\\) from the wavefunction:</p> \\[\\Psi(\\{\\kappa_i\\},t) = e^{i\\,F(t)}\\,\\tilde\\Psi(\\{\\kappa_i\\},t),\\] <p>where \\(\\tilde\\Psi\\) is the phase isolated wavefunction. Inserting this expression in the TD Shr\u00f6dinger equation results in:</p> \\[\\begin{aligned} &amp;\\left[\\hat H(\\lambda,t)-i \\frac{\\partial}{\\partial t}\\right]\\,\\tilde\\Psi(\\{\\kappa_i\\},t) = Q(t)\\,\\tilde\\Psi(\\{\\kappa_i\\},t),\\\\ &amp;\\text{ with } Q(t) = \\frac{\\partial F(t)}{\\partial t} = \\Braket{\\tilde\\Psi(\\{\\kappa_i\\},t)|\\hat H(\\lambda,t)-i \\frac{\\partial}{\\partial t}|\\tilde\\Psi(\\{\\kappa_i\\},t)}. \\end{aligned}\\] <p>As a result, \\(Q(t)\\), a real quantity, is called the TD quasienergy since it reduces to the energy \\(E_0\\) in the time-independent case. In Floquet theory, the perturbation is assumed to be periodic in time, of frequency \\(\\omega\\) (and period \\(T\\)), which means that \\(\\hat V(\\lambda,t)\\) oscillates at a multiple of the fundamental frequency \\(\\omega\\). Therefore, the Hamiltonian becomes periodic, which implies that \\(\\tilde{\\Psi}\\) also oscillates with the same period. As a consequence one can define the (time-averaged) quasienergy \\(\\mathcal{Q}\\) is given by:</p> \\[\\mathcal{Q} = \\frac{1}{T}\\,\\int_0^T dt\\,\\Braket{\\tilde\\Psi(\\{\\kappa_i\\},t)|\\hat H(\\lambda,t)-i \\frac{\\partial}{\\partial t}|\\tilde\\Psi(\\{\\kappa_i\\},t)}.\\] <p>The quasienergy \\(\\mathcal Q\\) acts similarly to \\(E\\) in the time-independent case, wich allows to obtain a TD version of the Hellman-Feynman theorem, and of the linear response equations. Using a Fourier series of \\(\\hat V\\), one can obtain a TD version of the linear response equations [Eqs. (1) and (2)].</p>"},{"location":"theory/#application-to-dft-td-dft","title":"Application to DFT: TD-DFT","text":"<p>Note</p> <p>In the following, \\(p\\), \\(q\\), \\(r\\), \\(s\\),... refer to molecular orbitals (MOs), \\(i\\), \\(j\\), \\(k\\), \\(l\\),... to occupied, \\(a\\), \\(b\\), \\(c\\), \\(d\\),... to unoccupied ones, \\(\\ket{m}\\), \\(\\ket{n}\\),... to electronic excited states, \\(\\mu\\), \\(\\nu\\), \\(\\xi\\)... to atomic orbitals (AOs) and \\(\\zeta\\), \\(\\sigma\\), \\(\\tau\\), \\(\\upsilon\\), ... to cartesian direction.  All quantities are in atomic units, unless otherwise mentioned.</p>"},{"location":"theory/#linear-response","title":"Linear response","text":"<p>Under the conditions of the Runge and Gross theorem, this theory can be applied to DFT. For a time-dependent perturbation at frequency \\(\\omega\\), and assuming the Hermicity of the different matrices and real orbitals, Eq. (2) can be written (the superscripts \\(\\lambda\\) have been dropped for clarity):</p> \\[\\tag{3}\\left[\\begin{pmatrix} \\mathbf A &amp; \\mathbf B \\\\ \\mathbf B &amp; \\mathbf A \\end{pmatrix}-\\omega\\begin{pmatrix} \\mathbf 1 &amp; \\mathbf 0\\\\ \\mathbf 0 &amp; -\\mathbf 1 \\end{pmatrix}\\right]\\,\\begin{pmatrix} \\mathbf x_\\zeta(\\omega)\\\\ \\mathbf y_\\zeta(\\omega) \\end{pmatrix}=-\\begin{pmatrix} \\mathbf \\eta_\\zeta\\\\ \\mathbf \\eta_\\zeta \\end{pmatrix},\\] <p>where \\(\\mathbf x_\\zeta(\\omega)\\) and \\(\\mathbf y_\\zeta(\\omega)\\) are the frequency-dependent linear response vectors (to be determined) in direction \\(\\zeta\\). The \\(\\mathbf A\\) and \\(\\mathbf B\\) are electronic Hessian (super-)matrices (related to orbital rotations). The perturbed electronic gradient vector elements \\(\\eta_{ia,\\zeta} = \\braket{i|\\hat\\eta_\\zeta|a}\\) are elements of the expectation value matrix corresponding to the perturbation (e.g., when the perturbation is an electric field, \\(\\hat\\eta\\) corresponds to the dipole moment operator).</p> <p>To solve this problem, Eq. (3) can be turned into a linear equation of the form:</p> \\[[(\\mathbf{A} + \\mathbf{B}) - \\omega^2(\\mathbf{A}-\\mathbf{B})^{-1}]\\,[\\mathbf x_\\zeta(\\omega) + \\mathbf y_\\zeta(\\omega)] = -2\\mathbf\\eta_\\zeta.\\] Detailed solution <p>The previous equation is easier seen as a linear system written in the following form:</p> \\[\\mathbf L(\\omega)\\,\\mathbf u_{\\zeta}(\\omega) = -2\\mathbf\\eta_\\zeta,\\] <p>where \\(\\mathbf L(\\omega) = (\\mathbf{A} + \\mathbf{B}) - \\omega^2(\\mathbf{A}-\\mathbf{B})^{-1}\\) and \\(\\mathbf u_{\\zeta}(\\omega)  = \\mathbf x_\\zeta(\\omega) + \\mathbf y_\\zeta(\\omega)\\), and which is solved using any of the usual methods for linear systems (worst case scenario: \\(\\mathbf u_\\zeta(\\omega) = -2\\mathbf L^{-1}(\\omega)\\,\\eta_\\zeta\\)). Then, since, from Eq. (3),</p> \\[\\mathbf x_\\zeta(\\omega) - \\mathbf y_\\zeta(\\omega) = \\omega\\,(\\mathbf A-\\mathbf B)^{-1}\\,[\\mathbf x_\\zeta(\\omega) + \\mathbf y_\\zeta(\\omega)],\\] <p>one can define \\(\\mathbf v_{\\zeta}(\\omega)\\) as:</p> \\[\\mathbf v_{\\zeta}(\\omega)  =\\mathbf x_\\zeta(\\omega) - \\mathbf y_\\zeta(\\omega) =  \\omega\\,(\\mathbf A-\\mathbf B)^{-1}\\,\\mathbf u_{\\zeta}(\\omega),\\] <p>the response vector are obtained: \\(\\mathbf x_{\\zeta}(\\omega) = \\frac{1}{2}[\\mathbf u_{\\zeta}(\\omega)  + \\mathbf v_{\\zeta}(\\omega)]\\) and \\(\\mathbf y_{\\zeta}(\\omega) = \\frac{1}{2}[\\mathbf u_{\\zeta}(\\omega)  - \\mathbf v_{\\zeta}(\\omega)]\\).</p> <p>The Tamm-Dancoff approximation (setting \\(\\mathbf B = \\mathbf 0\\) in all previous equations) can also be used.</p>"},{"location":"theory/#excitations","title":"Excitations","text":"<p>Since the pole of the response function corresponds to the electronic excited states, it is also customary to consider the case when \\(\\eta = 0\\), which lead to the following pseudo-hermitian problem:</p> \\[\\tag{4}\\begin{pmatrix} \\mathbf A &amp; \\mathbf B \\\\ \\mathbf B &amp; \\mathbf A \\end{pmatrix}\\,\\begin{pmatrix} \\mathbf x^m\\\\ \\mathbf y^m \\end{pmatrix}=\\omega_m\\begin{pmatrix} \\mathbf 1 &amp; \\mathbf 0\\\\ \\mathbf 0 &amp; -\\mathbf 1 \\end{pmatrix}\\,\\begin{pmatrix} \\mathbf x^m\\\\ \\mathbf y^m \\end{pmatrix}\\] <p>which is generally referred to as the Casida equation.  In this case, each \\(\\omega_m\\) (eigenvalue, corresponding to the transition energy bewteen \\(\\ket{0}\\) and \\(\\ket{m}\\)) is associated to one \\(\\mathbf x^m\\) and one \\(\\mathbf y^m\\) (\"eigenfunction\"), might be seen as amplitude vectors associated to excitation and de-excitation, respectively.  Solving this problem is done using two approaches.</p> <p>On the one hand, Eq. (4) can be rewritten in a true eigenvalue problem, namely:</p> \\[(\\mathbf{A}-\\mathbf{B})^\\frac{1}{2}\\,(\\mathbf{A}+\\mathbf{B})\\,(\\mathbf{A}-\\mathbf{B})^\\frac{1}{2}\\,\\mathbf{z}^m = \\omega^2\\,\\mathbf{z}^m, \\text{ with } \\mathbf{z}^m = (\\mathbf{A}-\\mathbf{B})^{-\\frac{1}{2}} (\\mathbf x^m + \\mathbf y^m).\\] Detailed solution <p>In this case, after \\(\\mathbf z^m\\) have been obtained, one extract using the following procedure. First, from previous expression, one can obtain:</p> \\[ \\mathbf u^m = \\mathbf x^m + \\mathbf y^m = \\frac{1}{\\sqrt\\omega}\\,(\\mathbf A-\\mathbf B)^\\frac{1}{2}\\,\\mathbf z^m.\\] <p>Now, since \\((\\mathbf A + \\mathbf B)\\,(\\mathbf x^m+\\mathbf y^m) = \\omega\\,(\\mathbf x^m-\\mathbf y^m)\\) [obtained from Eq. (4)], one has:</p> \\[\\mathbf v^m = \\mathbf x^m-\\mathbf y^m = \\frac{1}{\\omega}\\,(\\mathbf A + \\mathbf B)\\,(\\mathbf x^m+\\mathbf y^m)  = \\frac{1}{\\omega}\\,(\\mathbf A + \\mathbf B)\\,\\mathbf u^m,\\] <p>and therefore the response vector are obtained: \\(\\mathbf x^m = \\frac{1}{2}(\\mathbf u^m + \\mathbf v^m)\\) and \\(\\mathbf y^m = \\frac{1}{2}(\\mathbf u^m - \\mathbf v^m)\\).</p> <p>On the other hand, the Tamm-Dancoff approximation (\\(\\mathbf B = \\mathbf 0\\) and thus \\(\\mathbf y^m = 0\\)) simply leads to:</p> \\[\\mathbf A\\,\\mathbf x^m = \\omega_m\\,\\mathbf x^m.\\] <p>In this case, \\(\\ket{m} = \\sum_{ia}\\,x^m_{ia}\\,\\ket{\\Psi_i^a}\\), where \\(\\ket{\\Psi_i^a}\\) is a configuration state function, i.e., a singly-excited determinant where an electron has been moved from \\(i\\) to \\(a\\).</p> <p>In both cases, these amplitude vectors are linked to their linear response counterparts through the following spectral representation:</p> \\[\\begin{aligned} x_{ia,\\zeta}(\\omega) &amp;= \\sum_{\\ket{m}} \\eta_{ia,\\zeta}\\,(x^{m}_{ia} + y^{m}_{ia})\\,\\left[\\frac{x_{ia}^{m}}{\\omega-\\omega_m}-\\frac{y_{ia}^{m}}{\\omega+\\omega_m}\\right],\\\\ y_{ia,\\zeta}(\\omega) &amp;= \\sum_{\\ket{m}} \\eta_{ia,\\zeta}\\,(x^{m}_{ia} + y^{m}_{ia})\\,\\left[\\frac{y_{ia}^{m}}{\\omega-\\omega_m}-\\frac{x_{ia}^{m}}{\\omega+\\omega_m}\\right], \\end{aligned}\\] <p>where these expression involves a summation over the manifold \\(\\{\\ket{m}\\}\\) of excited states (and one can set \\(\\mathbf y^m = 0\\) to get the TDA version). These representations lead to simplification when taking residue of response functions.</p> <p>Implications</p> <p>From the spectral representations of \\(x_{ia,\\zeta}(\\omega)\\) and \\(y_{ia,\\zeta}(\\omega)\\), it is easy to see that:</p> \\[x_{ia,\\zeta}(0) = y_{ia,\\zeta}(0),\\] <p>and:</p> \\[x_{ia,\\zeta}(-\\omega) = y_{ia,\\zeta}(\\omega) \\land y_{ia,\\zeta}(-\\omega) = x_{ia,\\zeta}(\\omega).\\] <p>The latter is usefull to evaluate linear and quadratic response properties at the same time.</p>"},{"location":"theory/#the-simplified-approaches-to-td-dft","title":"The simplified approaches to TD-DFT","text":"<p>In the rest of this development a global hybrid density functional is assumed,</p> \\[E_{XC}= (1-a_x)\\,E_X^{GGA}+a_x\\,E_X^{HF}+E_C^{GGA}.\\] <p>Thanks to the Slater-Condon rules, one can evaluate the elements of \\(\\mathbf A\\) and \\(\\mathbf B\\), which are:</p> \\[\\begin{aligned} &amp;A_{ia, jb} = \\delta_{ij}\\delta_{ab} (\\varepsilon_a - \\varepsilon_i) + 2\\,(ia|jb) - a_x\\,(ij|ab) + (1-a_x)\\,(ia|f_{XC}|jb),\\\\ &amp;B_{ia,jb} = 2\\,(ia|bj) - a_x\\,(ib|aj) + (1-a_x)\\,(ia|f_{XC}|bj), \\end{aligned}\\] <p>where, \\(\\varepsilon_i\\) and \\(\\varepsilon_a\\) are orbital energies, \\(a_x\\) is the amount of non-local Fock exchange, \\((ia|jb)\\), \\((ia|bj)\\), and \\((ib|aj)\\) are exchange-type and \\((ij|ab)\\) Coulomb-type two-electron integrals, \\((ia|f_{XC}|jb)\\) and \\((ia|f_{XC}|bj)\\) are responses of the exchange-correlation functional.</p> <p>The simplified TD-DFT methods root in 3 approximations which simplify the content of \\(\\mathbf A\\) and \\(\\mathbf B\\):</p> <ol> <li>all integrals involving the XC-functionals are neglected (referred to as the random phase approximation (RPA) approach),</li> <li>the singly excited configuration space is truncated (see below), and</li> <li>the zero-differential overlap (ZDO) approximation is used for two-electron integrals which built \\(\\mathbf A\\) and \\(\\mathbf B\\). Different approximations for the remaining integrals define different flavors of simplified TD-DFT (see below).</li> </ol> <p>Then, using those approximated \\(\\mathbf A'\\) and \\(\\mathbf B'\\) matrices, the linear response or Casida equations presented above are solved.</p>"},{"location":"theory/#truncation-of-the-active-space","title":"Truncation of the active space","text":"<p>The truncation of the CI space is done in three steps:</p> <ol> <li>An active MO space is defined by \\(\\varepsilon_p \\in [\\varepsilon_{LUMO}-E_{w}, \\varepsilon_{HOMO}+E_{w}]\\), with \\(E_w = 2\\,(1+0.8a_x)\\,E_{thr}\\).</li> <li>From this active space, primary \\(\\ket{\\Psi_i^a}\\) configuration state functions (P-CSFs) are selected, for which \\(A_{ia,ia} &lt; E_{thr}\\).</li> <li>Then, from CSFs \\(\\ket{\\Psi_j^b}\\) for which \\(A_{jb,jb} &gt; E_{thr}\\), a set of secondary CSFs (S-CSFs), for which \\(E^{(2)}_{jb} &gt; E^{(2)}_{thr}\\) is build (typically, \\(E^{(2)}_{thr} = 10^{-4}\\)). Other CSFs are discarded.</li> </ol> <p>The selection of S-CSFs is based on a perturbative approach, where \\(E^{(2)}_{jb}\\) measure the cumulative perturbative contributions of a given S-CSF \\(\\ket{\\Psi_j^b}\\) to all the P-CSFs \\(\\ket{\\Psi_i^a}\\):</p> \\[E^{(2)}_{jb} = \\sum_{ia}^{\\text{P-CSFs}} \\frac{|A_{ia,jb}|^2}{A_{jb,jb}-A_{ia,ia}}.\\]"},{"location":"theory/#std-dft-or-the-monopole-approximation","title":"sTD-DFT, or the monopole approximation","text":"<p>To evaluate the integrals, a formula of the following kind is used:</p> \\[(ia|jb) \\approx (ia|jb)' = \\sum_{AB}^N q_A^{ia}\\,q_B^{jb}(AA|BB), \\text{ with } q_A^{ia} = \\sum_{\\mu\\in A} (C^{\\perp}_{i\\mu})^\\star\\,C^{\\perp}_{a\\mu},\\] <p>where the \\(q_{ia}^A\\)'s are the transition charges on atom A, computed using L\u00f6wdin orthogonalized LCAO coefficients, \\(C^\\perp_{i\\mu} = \\sum_\\nu C_{i\\nu}\\,S^{1/2}_{\\nu\\mu}\\).</p> Details of the application of the ZDO approximation <p>Starting from the definition of a 4-center integral:</p> \\[(ia|jb) = \\sum_{\\mu\\nu\\alpha\\beta} (C_{i\\mu})^\\star\\,C_{a\\nu}\\,(C_{j\\alpha})^\\star\\,C_{b\\beta}\\,(\\mu\\nu|\\alpha\\beta),\\] <p>one can instead use L\u00f6wdin orthogonalized molecular orbitals, \\(C^\\perp = C\\,S^{1/2}\\):</p> \\[(ia|jb) = \\sum_{\\mu\\nu\\alpha\\beta} (C^\\perp_{i\\mu})^\\star\\,C^\\perp_{a\\nu}\\,(C^\\perp_{j\\alpha})^\\star\\,C^\\perp_{b\\beta}\\,(\\lambda_\\mu\\lambda_\\nu|\\lambda_\\alpha\\lambda_\\beta),\\] <p>where \\(\\lambda_\\mu = \\sum_\\nu S^{-1/2}_{\\mu\\nu}\\,\\phi_\\nu\\). Now, the ZDO approximation impose that \\(\\lambda_\\mu\\,\\lambda_\\nu = \\delta_{\\mu\\nu}\\lambda_\\mu\\lambda_\\mu\\), so:</p> \\[(ia|jb) \\approx \\sum_{\\mu\\nu} (C^\\perp_{i\\mu})^\\star\\,C^\\perp_{a\\mu}\\,(C^\\perp_{j\\nu})^\\star\\,C^\\perp_{b\\nu}\\,(\\lambda_\\mu\\lambda_\\mu|\\lambda_\\nu\\lambda_\\nu).\\] <p>Finally, it is assumed that \\(\\lambda_\\mu\\lambda_\\mu \\approx \\mu\\mu\\), and therefore:</p> \\[(ia|jb) \\approx \\sum_{\\mu\\nu} (C^\\perp_{i\\mu})^\\star\\,C^\\perp_{a\\mu}\\,(C^\\perp_{j\\nu})^\\star\\,C^\\perp_{b\\nu}\\,(\\mu\\mu|\\nu\\nu).\\] <p>A simplification of the notation arise from population analysis, which allows to defines a transition charge:</p> \\[q_A^{ia} = \\sum_{\\mu\\in A} (C^{\\perp}_{i\\mu})^\\star\\,C^{\\perp}_{a\\mu},\\] <p>leading to the final expresssion.</p> <p>The remaining \\((AA|BB)\\) integrals are evaluated with Mataga\u2013Nishimoto\u2013Ohno\u2013Klopman (MNOK) damped Coulomb operators, according to the type of bielectronic integral that they approximate:</p> <ul> <li>For Coulomb-type integrals, \\((ij|ab)\\),</li> </ul> \\[(AA|BB)_J = \\left[\\frac{1}{R_{AB}^{\\gamma_J}+\\left(a_x\\,\\eta_{AB}\\right)^{-\\gamma_J}}\\right]^{1/\\gamma_J}.\\] <ul> <li>For exchange-type integrals, \\((ia|jb)\\),</li> </ul> \\[(AA|BB)_K = \\left[\\frac{1}{R_{AB}^{\\gamma_K}+\\eta_{AB}^{-\\gamma_K}}\\right]^{1/\\gamma_K}.\\] <p>In both cases, \\(\\eta_{AB} = \\frac{1}{2}\\,(\\eta_A + \\eta_B)\\) where \\(\\eta_A\\) is the chemical hardness of A (obtained from here), while \\(\\gamma_J\\) and \\(\\gamma_K\\) are globally fitted parameters.  </p> <p>In practice, the remaining elements of the (now approximated) electronic Hessian matrices \\(\\mathbf A'\\) and \\(\\mathbf B'\\) are:</p> \\[\\begin{aligned} A'_{ia,jb} =&amp; \\delta_{ij}\\delta_{ab} (\\varepsilon_a - \\varepsilon_i) + 2\\,(ia|jb)' - (ij|ab)',\\\\  B'_{ia,jb} =&amp; 2\\,(ia|bj)' -a_x\\,(ib|aj)'. \\end{aligned}\\] Implementation detail <p>In order to be computationally efficient, these element can be evaluated by precomputing three kind of transition charges: \\(q_A^{ij}\\), \\(q_A^{ia}\\), and \\(q_A^{ab}\\), and two intermediates:</p> \\[(ij|BB)_J = \\sum_A^N q_A^{ij}\\,(AA|BB)_J \\text{ and } (ia|BB)_K = \\sum_A^N q_A^{ia}\\,(AA|BB)_K,\\] <p>so that a scalar product leads to the value of the different integrals. For example,</p> \\[(ia|jb)' \\approx \\sum_{B}^N (ia|BB)_K\\,q_B^{jb}.\\] <p>However, these intermediates have a huge memory cost [\\(\\mathcal O (N_{atm}\\times N_{MO}^2)\\) altogether], so a direct version (integrals are evaluated when requested) is also available.</p>"},{"location":"theory/#xstd-dft","title":"XsTD-DFT","text":"<p>Warning</p> <p>The publication describing the XsTD-DFT implementation is not yet available. Thus, this approach is not yet implemented.</p>"},{"location":"theory/#expectation-values-and-others","title":"Expectation values and others","text":"<p>Things that can be obtained without solving the linear response equation.</p> <p>Note</p> <p>When required, conversion of \\(X\\) from the AO to the MO basis is done using:</p> \\[X^{MO}_{pq} = \\sum^{AO}_{\\mu\\nu} C_{p\\mu} X_{\\mu\\nu} C_{q\\nu}.\\]"},{"location":"theory/#density-matrix","title":"Density matrix","text":"<p>The density matrix elements are defined as:</p> \\[P_{\\mu\\nu} = \\sum^{MO}_p n_p\\,C^\\star_{p\\mu}\\,C_{p\\nu},\\] <p>where \\(n_p\\) is the occupancy of \\(p\\). If this is a closed shell calculation, occupied MO have an occupancy of 2, 0 otherwise.</p>"},{"location":"theory/#dipole-moment","title":"Dipole moment","text":"<p>The total dipole moment is obtained as:</p> \\[\\vec\\mu = \\vec\\mu_e + \\sum^{N_{nuc}}_A Z_A\\,\\vec r_A,\\] <p>where \\(Z_A\\) and \\(\\vec r_A\\) are the charge and position of nuclei \\(A\\), respectively. The electronic dipole moment, \\(\\vec\\mu_e\\), is an expectation value of the wavefunction. The electric dipole moment matrix elements (in AO basis) are computed as:</p> \\[D_{\\mu\\nu} = \\braket{\\mu|\\hat\\mu|\\nu} = -\\,\\braket{\\mu|\\vec{r}-\\vec R_0|\\nu},\\] <p>where the dipole moment integral have been multiplied by the value of the electronic charge (-1 in atomic units) and \\(\\vec R_0\\) is the origin. The electronic dipole moment is computed via:</p> \\[\\vec\\mu_e = \\sum^{AO}_{\\mu\\nu} P_{\\mu\\nu}\\,D_{\\nu\\mu} = tr(\\mathbf P\\mathbf D),\\] <p>where \\(\\mathbf P\\) is the density matrix. Alternatively, in MO basis:</p> \\[\\vec\\mu_e = \\sum^{MO}_p n_p\\,\\vec\\mu_{pp},\\] <p>where \\(\\vec\\mu_{pp}\\) is a shorthand for \\(D^{MO}_{pp}\\).</p>"},{"location":"theory/#responses-properties","title":"Responses (properties)","text":"<p>Things that can be obtained thanks to the amplitude/linear response vectors.</p> <p>Note</p> <p>Linear and quadratic response functions are generally noted \\(\\braket{\\braket{\\hat A; \\hat B}}_{\\omega_B}\\) and \\(\\braket{\\braket{\\hat A; \\hat B, \\hat C}}_{\\omega_B,\\omega_C}\\), which describes how the expectation value of \\(\\hat A\\) (at frequency \\(\\omega_A = -\\omega_B - \\omega_C\\)) responds to a set of perturbation to first and second order in perturbation. Residue of the response functions provide information on the (excited states of the) unperturbed system.</p> <p>For example, the linear response function might be extended in the following spectral representation:</p> \\[\\braket{\\braket{\\hat A; \\hat B}}_{\\omega_B} = \\sum_{\\ket{m}} \\frac{\\braket{0|\\hat A|m}\\braket{m|\\hat B|0}}{\\omega_B-\\omega_m} + \\frac{\\braket{0|\\hat B|m}\\braket{m|\\hat A|0}}{\\omega_A+\\omega_m},\\] <p>and a corresponding single residue might be:</p> \\[\\lim_{\\omega_B\\to\\omega_m} (\\omega_B-\\omega_m)\\,\\braket{\\braket{\\hat A; \\hat B}}_{\\omega_B} = \\braket{0|\\hat A|m}\\braket{m|\\hat B|0},\\] <p>which provides access to trasition matrix elements \\(\\braket{0|\\hat A|m}\\) between the ground state \\(\\ket{0}\\) and an excited state \\(\\ket{m}\\).  In practice, such residues are thus evaluated thanks to amplitude vectors through the spectral representation of linear responses.</p>"},{"location":"theory/#polarizability","title":"Polarizability","text":"<p>The dynamic (electric) polarizability tensor elements are defined:</p> \\[\\alpha_{\\zeta\\sigma}(-\\omega;\\omega) = -\\braket{\\braket{\\hat\\mu_\\zeta;\\hat\\mu_\\sigma}}_\\omega = -2\\,\\sum_{ia}^{CSF} \\mu_{ia,\\zeta}\\,[x_{ia,\\sigma}(\\omega)+y_{ia,\\sigma}(\\omega)].\\]"},{"location":"theory/#ground-to-excited-transition-dipole-moment-and-oscillator-strength","title":"Ground to excited transition dipole moment (and oscillator strength)","text":"<p>From the single residue of the electric polarizability, </p> \\[\\lim_{\\omega\\to\\omega_m} (\\omega-\\omega_m)\\,\\braket{\\braket{\\mu_\\zeta;\\mu_\\sigma}}_\\omega =  \\braket{0|\\hat\\mu_\\zeta|m}\\,\\braket{m|\\hat\\mu_\\sigma|0},\\] <p>the transition dipole moment elements (in the dipole length formalism) between ground \\(\\ket{0}\\) and excited state \\(\\ket{m}\\), associated with energy \\(\\omega_{m}\\) are given by:</p> \\[\\mu_{0m,\\zeta} = \\braket{0|\\hat\\mu_\\zeta|m} =  \\sqrt{2}\\,\\sum_{ia}^{CSF} \\vec\\mu_{ia,\\zeta}\\,(x^m_{ia}+y^m_{ia}),\\] <p>where \\(\\zeta\\) is a cartesian direction and the \\(\\sqrt 2\\) factor is required for singlet excitations (it is 0 for triplet). The associated oscillator strength is defined by:</p> \\[f_{0m} = \\frac{2}{3}\\,\\omega_m\\,|\\vec\\mu_{0m}|^2.\\]"},{"location":"theory/#first-hyperpolarizability","title":"First hyperpolarizability","text":"<p>By neglecting the response of the XC kernel and the Hartree XC kernel, the element of the first hyperpolarizability tensor in the sTD-DFT framework are:</p> \\[\\beta_{\\zeta\\sigma\\tau}(\\omega_\\varsigma;\\omega_1,\\omega_2) = -\\braket{\\braket{\\hat\\mu_\\zeta;\\hat\\mu_\\sigma,\\hat\\mu_\\tau}}_{\\omega_1,\\omega_2} = \\mathcal A_{\\zeta\\sigma\\tau}(\\omega_\\varsigma;\\omega_1,\\omega_2) - \\mathcal B_{\\zeta\\sigma\\tau}(\\omega_\\varsigma;\\omega_1,\\omega_2),\\] <p>with \\(\\omega_\\varsigma = -\\omega_1 - \\omega_2\\), and:</p> \\[\\begin{aligned} \\mathcal A_{\\zeta\\sigma\\tau}(\\omega_\\varsigma;\\omega_1,\\omega_2) &amp;= \\sum_{\\mathcal P} \\sum_{ia,ja} x_{ia,\\zeta}(\\omega_\\varsigma)\\,[-\\mu_{ij,\\sigma}]\\,y_{ja,\\tau}(\\omega_2), \\\\ \\mathcal B_{\\zeta\\sigma\\tau}(\\omega_\\varsigma;\\omega_1,\\omega_2) &amp;= \\sum_{\\mathcal P} \\sum_{ia,ib} x_{ia,\\zeta}(\\omega_\\varsigma)\\,[-\\mu_{ab,\\sigma}]\\,y_{ib,\\tau}(\\omega_2), \\end{aligned}\\] <p>where \\(\\sum_{\\mathcal P}\\) is the sum over the sequence of permutations of the pairs of components and energies, \\(\\{(\\zeta,\\omega_\\varsigma), (\\sigma, \\omega_1), (\\tau,\\omega_2)\\}\\).</p>"},{"location":"theory/#excited-to-excited-transition-dipole-moment-and-oscillator-strength","title":"Excited to excited transition dipole moment (and oscillator strength)","text":"<p>From the double residue of the electric first hyperpolarizability:</p> \\[\\begin{aligned} \\lim_{\\omega_1\\to-\\omega_m,\\omega_2\\to\\omega_n} &amp;(\\omega_1+\\omega_m)\\,(\\omega_2-\\omega_n)\\,\\braket{\\braket{\\hat\\mu_\\zeta;\\hat\\mu_\\sigma,\\hat\\mu_\\tau}}_{\\omega_1,\\omega_2}\\\\ &amp;=  \\braket{0|\\hat\\mu_\\zeta|m}\\,\\braket{m|\\hat\\mu_\\sigma - \\delta_{mn}\\,\\braket{0|\\hat\\mu_\\sigma|0}|n}\\,\\braket{n|\\hat\\mu_\\tau|0}, \\end{aligned}\\] <p>one extract the (unrelaxed) singlet-to-singlet transition dipole moment from \\(\\ket{m}\\) to \\(\\ket{n}\\) (see there):</p> \\[\\begin{aligned} &amp;\\braket{m|\\hat\\mu_\\zeta - \\delta_{mn}\\,\\braket{0|\\hat\\mu_\\zeta|0}|n}\\\\ &amp;\\hspace{2em}= \\frac{1}{2}\\left\\{ \\sum_{ia,ib} \\mu_{ab,\\zeta}\\,[x^n_{ia}\\,x^m_{ib} + y^m_{ia}\\,y^n_{ib}]  - \\sum_{ia,ja} \\mu_{ij,\\zeta}\\,[x^n_{ia}\\,x^m_{ja} + y^m_{ia}\\,y^n_{ja}] \\right\\}. \\end{aligned}\\] <p>which is equal to the fluctuation operator if \\(m = n\\). The corresponding oscillator strength is given by:</p> \\[f_{mn} = \\frac{2}{3}\\,(\\omega_n-\\omega_m)\\,(\\vec\\mu_{mn}\\cdot\\vec\\mu_{nm}).\\]"},{"location":"theory/#sources-and-references","title":"Sources and references","text":"<ul> <li>J. Toulouse, Introduction to the calculation of molecular properties by response theory (last consultation: January 2023). </li> <li>E. Fromager, Linear response time-dependent density functional theory  (last consultation: January 2023).</li> <li>G. P. Chen, V. K. Voora, M. M. Agee, S. G. Balasubramani, and F. Furche, Random-Phase Approximation Methods. Annu. Rev. Phys. Chem. 2017, 68, 421 (10.1146/annurev-physchem-040215-112308)</li> <li>M. E. Casida, Time-Dependent Density Functional Response Theory for Molecules. In D. E. Chong (ed.), Recent Advances in Density Functional Methods. World Scientific, 1995 (10.1142/9789812830586_0005).</li> <li>S. Hirata, M. Head-Gordon, Time-dependent density functional theory within the Tamm\u2013Dancoff approximation. Chem. Phys. Lett., 1999, 314, 291 (10.1016/S0009-2614(99)01149-5)</li> <li>S. L\u00f6ffelsender, P. Beaujean, M. de Wergifosse, Simplified quantum chemistry methods to evaluate non-linear optical properties of large systems. WIREs Comput. Mol. Sci. 2023, 2023, e1695 (10.1002/wcms.1695) [and references therein]. </li> <li>S. Grimme, A simplified Tamm-Dancoff density functional approach for the electronic excitation spectra of very large molecules. J Chem Phys. 2013, 138, 244104 (10.1063/1.4811331).</li> <li>C. Bannwarth, S. Grimme, A simplified time-dependent density functional theory approach for electronic ultraviolet and circular dichroism spectra of very large molecules. Comput Theor Chem. 2014, 1040, 45 (10.1016/j.comptc.2014.02.023).</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":"<p>It is possible to compute responses and properties within the sTD-DFT framework by using <code>libstdlite</code> through the <code>stdlite_run</code> program. This is obviously not restricted to <code>stdlite</code>, and also possible, e.g., with the original implementation called <code>stda</code>.  All implementations should normally give the same answer.</p> <p>Preamble</p> <p>To run a calculation, one needs a wavefunction from another quantum chemistry program as a source. Currently, two formats are supported: FHCK and MOLDEN. Utilities such as <code>iodata</code> provide ways to convert different outputs to one of these format (preferably MOLDEN).</p>"},{"location":"tutorial/#a-first-calculation-polarizabilities-and-beyond","title":"A first calculation: polarizabilities and beyond","text":"<p>The utility <code>stdlite_run</code> primarily read an input file written in the TOML format. For example, the following input set up a polarizability calculation, which is a linear response, given by \\(\\alpha(-\\omega;\\omega) = -\\braket{\\braket{\\mu;\\mu}}_\\omega\\), followed by a first hyperpolarizability calculation, a quadratic response, \\(\\beta(-\\omega_\\varsigma;\\omega_1,\\omega_2) = -\\braket{\\braket{\\mu;\\mu,\\mu}}_{\\omega_1,\\omega_2}\\) :</p> <pre><code>title = \"Calculation of the (hyper)polarizability of water (TDA approximation)\"\n\n[context]\n# source of the wavefunction and basis set:\nsource = \"water.molden\"\nsource_type = \"MOLDEN\"\n\n# parameters:\ngammaJ = 1.0\ngammaK = 0.5\nax = 1.0  # full HF exchange\nethr = '20eV'  # different units are supported\ntda = 0 # use the TD-DFT approach\n\n[responses]\n# compute linear response at 3 different frequencies\nlinear = [\n    {opA = 'dipl', opB = 'dipl', wB = 0}, # polarizability\n    {opA = 'dipl', opB = 'dipl', wB = '1064nm'},\n    {opA = 'dipl', opB = 'dipl', wB = '532nm'},\n]\n\n# compute quadratic response at 2 different frequencies\nquadratic = [\n    {opA = 'dipl', opB = 'dipl', opC = 'dipl', wB = 0, wC = 0},  # SHG first hyperpolarizability\n    {opA = 'dipl', opB = 'dipl', opC = 'dipl', wB = '1064nm', wC = '1064nm'},\n]\n</code></pre> <p>To perform the calculation, create a directory and download the inputs:</p> <pre><code>mkdir test\ncd tests\n\n# download source (water, computed at the HF/6-31G(d,f) level)\nwget https://github.com/pierre-24/stdlite/raw/master/docs/assets/water.molden\n\n# download TOML input\nwget https://github.com/pierre-24/stdlite/raw/master/docs/assets/example.toml\n</code></pre> <p>and run the program:</p> <pre><code>stdlite_run example.toml &gt; output.log\n</code></pre>"},{"location":"tutorial/#analysis-of-the-output","title":"Analysis of the output","text":"<p>As seen in the output file, a <code>stdlite</code> calculation is divided in different parts:</p> <ul> <li>Read the user input and check that everything is ok;</li> <li>Create the \"context\", i.e., a) read the wavefuntion in the MOLDEN file, b) select the CSFs, and c) build the corresponding \\(\\mathbf A'\\) and \\(\\mathbf B'\\) super-matrices;</li> <li>Compute the linear response and amplitude vectors;</li> <li>Use said vectors to compute actual properties (here, the polarizability and hyperpolarizabilities).</li> </ul> <p>Here, the result is:</p> <pre><code>--- Properties -----------------------------------------------------------------\nCompute polarizability tensor &gt;------&lt; done\n** alpha(-w;w), w=0.000000 (inf nm)\n         x            y            z\nx      1.62024      0.00000     -0.00000\ny      0.00000      7.02043      0.00000\nz     -0.00000      0.00000      3.69417\niso =        4.11162\naniso =      4.71843\nCompute polarizability tensor &gt;------&lt; done\n** alpha(-w;w), w=0.042823 (1064.00 nm)\n         x            y            z\nx      1.62570      0.00000     -0.00000\ny      0.00000      7.05151      0.00000\nz     -0.00000      0.00000      3.71297\niso =        4.13006\naniso =      4.74035\nCompute polarizability tensor &gt;------&lt; done\n** alpha(-w;w), w=0.085645 (532.00 nm)\n         x            y            z\nx      1.64285      0.00000     -0.00000\ny      0.00000      7.14678      0.00000\nz     -0.00000      0.00000      3.77115\niso =        4.18692\naniso =      4.80717\nCompute first hyperpolarizability tensor &gt;------------------&lt; done\n** beta(-w1-w2;w1,w2), w1=0.000000 (inf nm), w2=0.000000 (inf nm)\n          x            y            z\nxx      0.00000      0.00000      1.17469\nxy      0.00000      0.00000      0.00000\nxz      1.17469      0.00000     -0.00000\nyx      0.00000      0.00000      0.00000\nyy      0.00000      0.00000     12.28710\nyz      0.00000     12.28710      0.00000\nzx      1.17469      0.00000     -0.00000\nzy      0.00000     12.28710      0.00000\nzz     -0.00000      0.00000      9.31467\n&lt;B2ZZZ&gt; =     75.54126\n&lt;B2ZXX&gt; =     15.77636\nBHRS    =      9.55603\nDR      =      4.78826\nCompute first hyperpolarizability tensor &gt;------------------&lt; done\n** beta(-w1-w2;w1,w2), w1=0.042823 (1064.00 nm), w2=0.042823 (1064.00 nm)\n          x            y            z\nxx      0.00000      0.00000      1.25188\nxy      0.00000      0.00000      0.00000\nxz      1.25188      0.00000     -0.00000\nyx      0.00000      0.00000      0.00000\nyy      0.00000      0.00000     12.72614\nyz      0.00000     12.72614      0.00000\nzx      1.21095      0.00000     -0.00000\nzy      0.00000     12.72475      0.00000\nzz     -0.00000      0.00000      9.73270\n&lt;B2ZZZ&gt; =     81.56844\n&lt;B2ZXX&gt; =     16.89920\nBHRS    =      9.92309\nDR      =      4.82676\n</code></pre>"},{"location":"tutorial/#to-go-further","title":"To go further","text":"<p>It is also possible to pass arguments to the program, which takes precedence over the input file. For example, to compute the same response with the Tamm-Dancoff approximation:</p> <pre><code># this is equivalent to `tda = 1` in example.toml\nstdlite_run example.toml --ctx_tda=1 &gt; output.log\n</code></pre> <p>In this case, the results are similar with or without the Tamm-Dancoff approximation. This might not be the case for other systems.</p> <p>You can also change the amount of molecular orbitals that are included:</p> <pre><code># this is equivalent to `ethr = '25eV'` in example.toml\nstdlite_run example.toml --ctx_ethr=25eV &gt; output.log\n</code></pre> <p>In this case, 16 MOs and 28 CSFs are considered, rather than \"only\" 15 MOs and 23 CSFs when the threshold energy was of 20 eV.</p>"},{"location":"tutorial/#a-second-calculation-excitation-energies","title":"A second calculation: excitation energies","text":"<p>Excitation energies are obtained by solving the Casida equation, while ground to excited dipole moments are computed as the first residue of the linear response function, \\(\\lim_{\\omega\\to\\omega_m}\\braket{\\braket{\\mu;\\mu}}_\\omega\\).</p> <p>The input file now looks like this (<code>linear_sr</code> request the single residue of linear response):</p> <pre><code>title = \"Calculation of excitation energies of water (TDA)\"\n\n[context]\n# source of the wavefunction and basis set:\nsource = \"water.molden\"\nsource_type = \"MOLDEN\"\n\n# parameters:\ngammaJ = 1.0\ngammaK = 0.5\nax = 1.0\nethr = '20eV'\ntda = 1 # use Tamm-Dancoff approximation\n\n[responses]\n\n# compute the 10 first excitation energies\nlinear_sr = [\n    {opA = 'dipl', nroots = 10},  # transition dipole\n]\n</code></pre> <p>This time, the Tamm-Dancoff approximation was requested.</p> <p>Run the program:</p> <pre><code># download this TOML input\nwget https://github.com/pierre-24/stdlite/raw/master/docs/assets/example.toml\n\n# run the program\nstdlite_run example2.toml &gt; output2.log\n</code></pre> <p>This time, once the wavefunction is extracted and \\(\\mathbf A'\\) is built, the amplitude vectors are computed.</p>"},{"location":"tutorial/#analysis-of-the-output_1","title":"Analysis of the output","text":"<p>The result list each excitation energies with its corresponding transition dipole moment, and the resulting oscillator strength (<code>fL</code>), and then the main contribution to each excitation.</p> <pre><code>--- Properties -----------------------------------------------------------------\nCompute ground to excited transition dipole moments &gt;&lt; done\n**    -------- Energy -------- ------ Transition dipole ---------\n       (Eh)     (eV)    (nm)      X        Y        Z      fL   \n   1  0.36143   9.835  126.06  0.23181  0.00000  0.00000 0.01295\n   2  0.45262  12.317  100.66  0.00000 -0.00000  0.62895 0.11937\n   3  0.45320  12.332  100.54 -0.00000 -0.00000 -0.00001 0.00000\n   4  0.53684  14.608   84.87 -0.00000 -0.74083 -0.00000 0.19642\n   5  0.60510  16.466   75.30 -0.00000 -0.98007 -0.00000 0.38748\n   6  0.77077  20.974   59.11  0.00000 -0.00000  0.64883 0.21632\n   7  1.08574  29.544   41.97 -0.00000 -0.00000 -0.00000 0.00000\n   8  1.11337  30.296   40.92  0.11547  0.00000  0.00000 0.00990\n   9  1.17348  31.932   38.83 -0.00000  0.73807  0.00000 0.42617\n  10  1.21420  33.040   37.53  0.00000  0.00000 -0.16143 0.02110\n**   -- E --- ------- Contributions -------\n   1  0.36143  99.6% ( 0.7055) H\u2192L\n                0.4% (-0.0449) H\u2192L+3\n     -------- -----------------------------\n   2  0.45262  98.5% ( 0.7016) H-1\u2192L\n                0.9% (-0.0658) H-2\u2192L+1\n                0.3% ( 0.0412) H-3\u2192L\n                0.1% (-0.0267) H-1\u2192L+3\n                0.1% (-0.0249) H-2\u2192L+2\n     -------- -----------------------------\n   3  0.45320  99.1% ( 0.7039) H\u2192L+1\n                0.5% ( 0.0524) H\u2192L+2\n                0.4% ( 0.0423) H\u2192L+6\n     -------- -----------------------------\n   4  0.53684  99.2% (-0.7044) H-1\u2192L+1\n                0.3% (-0.0390) H-1\u2192L+2\n                0.1% (-0.0232) H-3\u2192L+1\n                0.3% (-0.0369) H-1\u2192L+6\n     -------- -----------------------------\n   5  0.60510  99.8% (-0.7063) H-2\u2192L\n                0.1% ( 0.0231) H-1\u2192L+2\n     -------- -----------------------------\n   6  0.77077   0.7% ( 0.0573) H-1\u2192L\n               95.1% ( 0.6895) H-2\u2192L+1\n                3.0% ( 0.1227) H-3\u2192L\n                0.6% ( 0.0569) H-1\u2192L+3\n                0.4% (-0.0456) H-2\u2192L+2\n                0.2% (-0.0300) H-3\u2192L+3\n     -------- -----------------------------\n   7  1.08574   0.3% (-0.0381) H\u2192L+1\n               91.4% ( 0.6760) H\u2192L+2\n                8.3% (-0.2037) H\u2192L+6\n     -------- -----------------------------\n   8  1.11337  99.7% (-0.7061) H\u2192L+5\n                0.2% ( 0.0353) H\u2192L+3\n     -------- -----------------------------\n   9  1.17348   0.2% (-0.0315) H-1\u2192L+1\n               91.7% ( 0.6773) H-1\u2192L+2\n                2.0% ( 0.0989) H-3\u2192L+1\n                5.9% (-0.1716) H-1\u2192L+6\n                0.1% ( 0.0226) H-3\u2192L+2\n     -------- -----------------------------\n  10  1.21420  99.5% ( 0.7054) H-1\u2192L+5\n                0.4% (-0.0446) H-1\u2192L+3\n</code></pre> <p>For example, the first excitation has a strong (&gt;99%) HOMO\u2192LUMO character.</p>"},{"location":"tutorial/#to-go-further_1","title":"To go further","text":"<p>You can totally combine linear/quadratic response calculations and excitations with the following input:</p> <pre><code># compute the static polarizability\nlinear = [\n    {opA = 'dipl', opB = 'dipl', wB = 0}, \n]\n\n# compute the static hyperpolarizability\nquadratic = [\n    {opA = 'dipl', opB = 'dipl', opC = 'dipl', wB = 0, wC = 0},\n]\n\n# compute the 10 first excitation energies\nlinear_sr = [\n    {opA = 'dipl', nroots = -1},\n]\n</code></pre> <p>Note that <code>nroots=-1</code> request the computation of all possible excitations (in this case, 23), which might take longer.</p>"},{"location":"API/","title":"Public API documentation","text":"<p>This section describes the public API of <code>libstdlite</code>.</p>"},{"location":"API/#basic-principles","title":"Basic principles","text":"<ul> <li> <p>Unless otherwise mentioned, everything inputs and outputs are (to be) given in atomic units (of energy [hartree], of length [bohr], etc).</p> </li> <li> <p>Every object, enum, macro, or function that belongs to the public library API starts with <code>stdl_</code> (or <code>STDL_</code>).   Everything that does not is internal, and subject to change without notice.</p> </li> <li> <p>Every array is stored in the usual row major form rather than the usual in fortran, column major.</p> </li> <li> <p>The user is required delete all objects created within the library by using the provided deletor functions to avoid memory leaks.   Furthermore, each function return an error code (see logging and errors or <code>STDL_ERR_OK</code> if everything went well.   For example,</p> </li> </ul> <pre><code>#include &lt;stdlite/utils/base_parser.h&gt;\n\nint an_integer, error;\nstdl_lexer* lexer = NULL;\nFILE* f = open(\"tmp.txt\");\n\nif(f != NULL) {\n  if(stdl_lexer_new(&amp;lexer, f) == STDL_ERR_OK) {\n    if(stdl_parser_get_integer(lx, &amp;an_integer) == STDL_ERR_OK) {\n      printf(\"read: %d\\n\", an_integer);\n    }\n\n    stdl_lexer_delete(lexer); // deletor\n  }\n\n  fclose(f);\n}\n</code></pre> <ul> <li>Apart from the creator functions (<code>stdl_*_new()</code>) and stuffs that comes from files (FCHK or MOLDEN), the principle for outputs is \"bring-your-own-space\".    In other words, unless otherwise mentioned, outputs of functions (especially arrays) must have been allocated to their correct size.</li> </ul>"},{"location":"API/#general-workflow","title":"General workflow","text":"<p>The general workflow to use <code>libstdlite</code> in order to compute a given property is the following:</p> <p></p>"},{"location":"API/#specific-topics","title":"Specific topics","text":"Logging and errors Handling of log, of errors, and of error messages. Wavefunction Store the result of a QC calculation, which is the input for subsequent (s)TD-DFT calculations. Basis set Describe a set of basis functions, centered on atoms. Context handler Setup and modify a calculation. Properties Use the linear response vectors to compute some properties. Response functions Solve the linear response problem or the Casida equation. Helpers functions and macros Helpers functions and macros. Utilities Utility functions, not directly required to use the library. The application API of <code>stdlite_run</code>."},{"location":"API/app/","title":"The application","text":"<p>API of <code>stdlite_run</code>.</p> Miscellaneous Helper function for the application. User input handler Deals with all user inputs and convert that into requests. Requests for response Handle bare response and linear response vector requests. Responses handler Deals with responses, by computing them. Print out property Print out (in log) the different properties ```c #include \"log_property."},{"location":"API/app/app_main/","title":"Miscellaneous","text":"<p>Helper function for the application.</p> <pre><code>#include \"app.h\"\n</code></pre>"},{"location":"API/app/app_main/#functions","title":"Functions","text":"Name Description stdl_app_log_env Log the environment variables  Return :    error code stdl_app_set_debug_log_level Set the debug and log level, using two environment variables: <code>STDL_LOG_LEVEL</code> and <code>STDL_DEBUG_LEVEL</code> Return :    error code stdl_timer_start Create a timer  Parameter <code>t</code> :    a valid <code>timespec</code> structure stdl_timer_stop Get the elapsed time (in second)  Parameter <code>start</code> :    a valid <code>timespec</code> structure initialized with <code>stdl_timer_start</code> Return :    the number of second since <code>start</code>"},{"location":"API/app/app_main/#function-details","title":"Function Details","text":""},{"location":"API/app/app_main/#stdl_app_log_env","title":"stdl_app_log_env","text":"<p>int stdl_app_log_env()</p> <p>Log the environment variables</p> Return error code"},{"location":"API/app/app_main/#stdl_app_set_debug_log_level","title":"stdl_app_set_debug_log_level","text":"<p>int stdl_app_set_debug_log_level()</p> <p>Set the debug and log level, using two environment variables: <code>STDL_LOG_LEVEL</code> and <code>STDL_DEBUG_LEVEL</code></p> Return error code"},{"location":"API/app/app_main/#stdl_timer_start","title":"stdl_timer_start","text":"<p>void stdl_timer_start(tmspec * t)</p> <p>Create a timer</p> Parameter <code>t</code> a valid <code>timespec</code> structure"},{"location":"API/app/app_main/#stdl_timer_stop","title":"stdl_timer_stop","text":"<p>double stdl_timer_stop(tmspec * start)</p> <p>Get the elapsed time (in second)</p> Parameter <code>start</code> a valid <code>timespec</code> structure initialized with <code>stdl_timer_start</code> Return the number of second since <code>start</code>"},{"location":"API/app/log_property/","title":"Print out property","text":"<p>Print out (in log) the different properties</p> <pre><code>#include \"log_property.h\"\n</code></pre>"},{"location":"API/app/log_property/#functions","title":"Functions","text":"Name Description stdl_log_property_first_hyperpolarizability Print the first hyperpolarizability tensor and its corresponding experimental quantities. stdl_log_property_g2e_dipoles Print the ground to excited dipole moments, as well as the contributin of each CSFs (if above <code>thresh</code>, to a given dipole moment)  Parameter <code>rh</code> :    a valid responses handler  Parameter <code>ctx</code> :    a valid context  Parameter <code>tdips</code> :    transition dipoles  Parameter <code>thresh</code> :    threshold for the contributions  Return :    error code stdl_log_property_polarizability Print the polarizability tensor and its corresponding experimental quantities."},{"location":"API/app/log_property/#function-details","title":"Function Details","text":""},{"location":"API/app/log_property/#stdl_log_property_first_hyperpolarizability","title":"stdl_log_property_first_hyperpolarizability","text":"<p>int stdl_log_property_first_hyperpolarizability(stdl_response_request* req, float beta[3][3][3])</p> <p>Print the first hyperpolarizability tensor and its corresponding experimental quantities.</p> Parameter <code>req</code> a valid response request Parameter <code>beta</code> <code>float[3,3,3]</code> the hyperpolarizability tensor Return error code"},{"location":"API/app/log_property/#stdl_log_property_g2e_dipoles","title":"stdl_log_property_g2e_dipoles","text":"<p>int stdl_log_property_g2e_dipoles(stdl_responses_handler *rh, stdl_context *ctx, float *tdips, float thresh)</p> <p>Print the ground to excited dipole moments, as well as the contributin of each CSFs (if above <code>thresh</code>, to a given dipole moment)</p> Parameter <code>rh</code> a valid responses handler Parameter <code>ctx</code> a valid context Parameter <code>tdips</code> transition dipoles Parameter <code>thresh</code> threshold for the contributions Return error code"},{"location":"API/app/log_property/#stdl_log_property_polarizability","title":"stdl_log_property_polarizability","text":"<p>int stdl_log_property_polarizability(stdl_response_request* req, float* alpha)</p> <p>Print the polarizability tensor and its corresponding experimental quantities.</p> Parameter <code>req</code> a valid response request Parameter <code>alpha</code> <code>float[6]</code> the polarizability tensor Return error code"},{"location":"API/app/requests/","title":"Requests for response","text":"<p>Handle bare response and linear response vector requests.</p> <pre><code>#include \"response_requests.h\"\n</code></pre>"},{"location":"API/app/requests/#types","title":"Types","text":"Name Description stdl_lrv_request_ Linear response vectors (LRV) requests, in an orderly manner. stdl_operator_ Operators for the linear responses stdl_response_request_ Any response request from the TOML file."},{"location":"API/app/requests/#functions","title":"Functions","text":"Name Description stdl_lrv_request_compute Actually compute the requested linear response vectors  Parameter <code>lrvreq</code> :    a valid request  Parameter <code>op_MO</code> :    <code>double[dim,ctx-&gt;nmo,ctx-&gt;nmo]</code> elements of $\\braket{p stdl_lrv_request_delete Delete a LRV request. stdl_lrv_request_dump_h5 Dump a LRV request. stdl_lrv_request_new Create a new linear response vectors request for <code>op</code> at <code>nw</code> energies. stdl_operator_dim Get the dimension of a given operator  Parameter <code>op</code> :    the operator  Parameter <code>dim</code> :    its dimension  Return :    error code stdl_response_request_delete Delete a request. stdl_response_request_new Create a new response request."},{"location":"API/app/requests/#function-details","title":"Function Details","text":""},{"location":"API/app/requests/#stdl_lrv_request_compute","title":"stdl_lrv_request_compute","text":"<p>int stdl_lrv_request_compute(stdl_lrv_request *lrvreq, stdl_context *ctx)</p> <p>Actually compute the requested linear response vectors</p> Parameter <code>lrvreq</code> a valid request Parameter <code>op_MO</code> <code>double[dim,ctx-&gt;nmo,ctx-&gt;nmo]</code> elements of \\(\\braket{p|op|q}\\). Return error code"},{"location":"API/app/requests/#stdl_lrv_request_delete","title":"stdl_lrv_request_delete","text":"<p>int stdl_lrv_request_delete(stdl_lrv_request* req)</p> <p>Delete a LRV request.</p> Parameter <code>req</code> a valid request Return error code"},{"location":"API/app/requests/#stdl_lrv_request_dump_h5","title":"stdl_lrv_request_dump_h5","text":"<p>int stdl_lrv_request_dump_h5(stdl_lrv_request *req, stdl_context *ctx, hid_t group_id)</p> <p>Dump a LRV request.</p> Parameter <code>req</code> a valid request Parameter <code>group_id</code> a valid H5 group Return error code"},{"location":"API/app/requests/#stdl_lrv_request_new","title":"stdl_lrv_request_new","text":"<p>int stdl_lrv_request_new(stdl_operator op, size_t nw, size_t ncsfs, stdl_lrv_request **req_ptr)</p> <p>Create a new linear response vectors request for <code>op</code> at <code>nw</code> energies.</p> Parameter <code>op</code> operator Parameter <code>nw</code> number of energies Parameter <code>req_ptr</code> resulting request Return error code"},{"location":"API/app/requests/#stdl_operator_dim","title":"stdl_operator_dim","text":"<p>int stdl_operator_dim(stdl_operator op, size_t* dim)</p> <p>Get the dimension of a given operator</p> Parameter <code>op</code> the operator Parameter <code>dim</code> its dimension Return error code"},{"location":"API/app/requests/#stdl_response_request_delete","title":"stdl_response_request_delete","text":"<p>int stdl_response_request_delete(stdl_response_request* req)</p> <p>Delete a request.</p> Parameter <code>req</code> a valid request Return error code"},{"location":"API/app/requests/#stdl_response_request_new","title":"stdl_response_request_new","text":"<p>int stdl_response_request_new(size_t resp_order, size_t res_order, stdl_operator* ops, float* w, int nroots, stdl_response_request** req_ptr)</p> <p>Create a new response request.</p> Parameter <code>resp_order</code> Order of the response, must be &gt; 0. Parameter <code>res_order</code> Order of the residue, must be <code>res_order &lt; resp_order</code> Parameter <code>ops</code> operators Parameter <code>w</code> energies at which linear response vectors should be computed Parameter <code>nroots</code> number of excitations (and, thus, amplitude vectors) that should be computed. Negative number means \"all\" Parameter <code>req_ptr</code> the resulting request Return error code"},{"location":"API/app/requests/stdl_lrv_request_/","title":"stdl_lrv_request_","text":"<p>struct stdl_lrv_request_</p> <p>Linear response vectors (LRV) requests, in an orderly manner. Also store linear vectors when computed.</p>"},{"location":"API/app/requests/stdl_lrv_request_/#variables","title":"Variables","text":"Name Description op Operator dim Dimensionality of <code>op</code> eta_MO pointer to the MO representation of <code>op</code> egrad <code>float[]</code> perturbed gradient nw Number of energies at which the vectors should be computed w <code>float[nw]</code>, the energies X <code>float[nw,nscfs,dim]</code> The linear response vector \\(\\mathbf x(\\omega)\\) Y <code>float[nw,nscfs,dim]</code> The linear response vector \\(\\mathbf y(\\omega)\\)"},{"location":"API/app/requests/stdl_lrv_request_/#variable-details","title":"Variable Details","text":""},{"location":"API/app/requests/stdl_lrv_request_/#x","title":"X","text":"<p>float* X</p> <p><code>float[nw,nscfs,dim]</code> The linear response vector \\(\\mathbf x(\\omega)\\)</p>"},{"location":"API/app/requests/stdl_lrv_request_/#y","title":"Y","text":"<p>float* Y</p> <p><code>float[nw,nscfs,dim]</code> The linear response vector \\(\\mathbf y(\\omega)\\)</p>"},{"location":"API/app/requests/stdl_lrv_request_/#dim","title":"dim","text":"<p>size_t dim</p> <p>Dimensionality of <code>op</code></p>"},{"location":"API/app/requests/stdl_lrv_request_/#egrad","title":"egrad","text":"<p>float* egrad</p> <p><code>float[]</code> perturbed gradient</p>"},{"location":"API/app/requests/stdl_lrv_request_/#eta_mo","title":"eta_MO","text":"<p>double* eta_MO</p> <p>pointer to the MO representation of <code>op</code></p>"},{"location":"API/app/requests/stdl_lrv_request_/#nw","title":"nw","text":"<p>size_t nw</p> <p>Number of energies at which the vectors should be computed</p>"},{"location":"API/app/requests/stdl_lrv_request_/#op","title":"op","text":"<p>stdl_operator op</p> <p>Operator</p>"},{"location":"API/app/requests/stdl_lrv_request_/#w","title":"w","text":"<p>float* w</p> <p><code>float[nw]</code>, the energies</p>"},{"location":"API/app/requests/stdl_operator_/","title":"stdl_operator_","text":"<p>enum stdl_operator_</p> <p>Operators for the linear responses</p> STDL_OP_DIPL Dipole length operator"},{"location":"API/app/requests/stdl_response_request_/","title":"stdl_response_request_","text":"<p>struct stdl_response_request_</p> <p>Any response request from the TOML file. It is a chained list.</p>"},{"location":"API/app/requests/stdl_response_request_/#types","title":"Types","text":"Name Description stdl_lrv_request_ <code>stdl_linear_response_vectors_request[resp_order-res_order]</code> for each operator (except the first one), the corresponding linear response vector request stdl_response_request_ Next request"},{"location":"API/app/requests/stdl_response_request_/#variables","title":"Variables","text":"Name Description resp_order order of the response (1 = linear, 2 = quadratic, etc) res_order number of residues (0 = none, 1 = first residue, 2 = second residue) ops <code>stdl_operator[resp_order-res_order+1]</code> the operators associated with the request w `float[(resp_order == res_order)? nroots number of amplitude vectors (*i. wpos `size_t[(resp_order == res_order)?"},{"location":"API/app/requests/stdl_response_request_/#variable-details","title":"Variable Details","text":""},{"location":"API/app/requests/stdl_response_request_/#nroots","title":"nroots","text":"<p>int nroots</p> <p>number of amplitude vectors (i.e., excitations) requested, any negatives number means \"all\"</p>"},{"location":"API/app/requests/stdl_response_request_/#ops","title":"ops","text":"<p>stdl_operator *ops</p> <p><code>stdl_operator[resp_order-res_order+1]</code> the operators associated with the request</p>"},{"location":"API/app/requests/stdl_response_request_/#res_order","title":"res_order","text":"<p>size_t res_order</p> <p>number of residues (0 = none, 1 = first residue, 2 = second residue)</p>"},{"location":"API/app/requests/stdl_response_request_/#resp_order","title":"resp_order","text":"<p>size_t resp_order</p> <p>order of the response (1 = linear, 2 = quadratic, etc)</p>"},{"location":"API/app/requests/stdl_response_request_/#w","title":"w","text":"<p>float* w</p> <p><code>float[(resp_order == res_order)? 0: resp_order-res_order+1]</code> the energies at which linear response vectors should be computed</p>"},{"location":"API/app/requests/stdl_response_request_/#wpos","title":"wpos","text":"<p>size_t* wpos</p> <p><code>size_t[(resp_order == res_order)? 0: resp_order-res_order+1]</code> For each frequency, its corresponding position in the linear response vector request</p>"},{"location":"API/app/requests/stdl_response_request_/stdl_lrv_request_/","title":"Index","text":"<p>title: stdl_lrv_request_ description:  <code>stdl_linear_response_vectors_request[resp_order-res_order]</code> for each operator (except the first one), the corresponding linear response vector request  generator: doxide</p>"},{"location":"API/app/requests/stdl_response_request_/stdl_lrv_request_/#stdl_lrv_request_","title":"stdl_lrv_request_","text":"<p>struct stdl_lrv_request_</p> <p><code>stdl_linear_response_vectors_request[resp_order-res_order]</code> for each operator (except the first one), the corresponding linear response vector request</p>"},{"location":"API/app/requests/stdl_response_request_/stdl_response_request_/","title":"stdl_response_request_","text":"<p>struct stdl_response_request_</p> <p>Next request</p>"},{"location":"API/app/responses_handler/","title":"Responses handler","text":"<p>Deals with responses, by computing them.</p> <pre><code>#include \"responses_handler.h\"\n</code></pre>"},{"location":"API/app/responses_handler/#types","title":"Types","text":"Name Description stdl_responses_handler_ Handler for responses"},{"location":"API/app/responses_handler/#functions","title":"Functions","text":"Name Description stdl_responses_handler_compute Compute linear/amplitude vectors. stdl_responses_handler_delete Delete handler. stdl_responses_handler_new Create a new responses handler."},{"location":"API/app/responses_handler/#function-details","title":"Function Details","text":""},{"location":"API/app/responses_handler/#stdl_responses_handler_compute","title":"stdl_responses_handler_compute","text":"<p>int stdl_responses_handler_compute(stdl_responses_handler* rh, stdl_context* ctx)</p> <p>Compute linear/amplitude vectors.</p> Parameter <code>rh</code> a valid responses handler Parameter <code>ctx</code> a valid context Return error code"},{"location":"API/app/responses_handler/#stdl_responses_handler_delete","title":"stdl_responses_handler_delete","text":"<p>int stdl_responses_handler_delete(stdl_responses_handler* rh)</p> <p>Delete handler.</p> Parameter <code>rh</code> a valid handler Return error code"},{"location":"API/app/responses_handler/#stdl_responses_handler_new","title":"stdl_responses_handler_new","text":"<p>int stdl_responses_handler_new(size_t nops, size_t nlrvreqs, size_t nexci, char *data_output, stdl_context *ctx, stdl_responses_handler **rh_ptr)</p> <p>Create a new responses handler.</p> Parameter <code>nops</code> Number of operators Parameter <code>nlrvreqs</code> number of linear response vectors (LRV) requests Parameter <code>nexci</code> number of excitations Parameter <code>rh_ptr</code> resulting handler Return error code"},{"location":"API/app/responses_handler/stdl_responses_handler_/","title":"stdl_responses_handler_","text":"<p>struct stdl_responses_handler_</p> <p>Handler for responses</p>"},{"location":"API/app/responses_handler/stdl_responses_handler_/#variables","title":"Variables","text":"Name Description nops Number of operators ops <code>stdl_operator[nops]</code> list of operators nlrvreqs <code>double[nops]</code>, &lt;r nexci <code>stdl_lrv_request*[nlrvreqs]</code> Corresponding linear response vectors requests Number of excited states requested eexci <code>float[nexci]</code> the excitation energies Xamp <code>float[nexci,ncsfs]</code> amplitude vector \\(\\mathbf x^m\\) for each excitation \\(\\ket{m}\\) Yamp <code>float[nexci,ncsfs]</code> amplitude vector \\(\\mathbf y^m\\) for each excitation \\(\\ket{m}\\), might be <code>NULL</code> if TDA data_output place to save responses"},{"location":"API/app/responses_handler/stdl_responses_handler_/#variable-details","title":"Variable Details","text":""},{"location":"API/app/responses_handler/stdl_responses_handler_/#xamp","title":"Xamp","text":"<p>float* Xamp</p> <p><code>float[nexci,ncsfs]</code> amplitude vector \\(\\mathbf x^m\\) for each excitation \\(\\ket{m}\\)</p>"},{"location":"API/app/responses_handler/stdl_responses_handler_/#yamp","title":"Yamp","text":"<p>float* Yamp</p> <p><code>float[nexci,ncsfs]</code> amplitude vector \\(\\mathbf y^m\\) for each excitation \\(\\ket{m}\\), might be <code>NULL</code> if TDA</p>"},{"location":"API/app/responses_handler/stdl_responses_handler_/#data_output","title":"data_output","text":"<p>char* data_output</p> <p>place to save responses</p>"},{"location":"API/app/responses_handler/stdl_responses_handler_/#eexci","title":"eexci","text":"<p>float* eexci</p> <p><code>float[nexci]</code> the excitation energies</p>"},{"location":"API/app/responses_handler/stdl_responses_handler_/#nexci","title":"nexci","text":"<p>size_t nexci</p> <p><code>stdl_lrv_request*[nlrvreqs]</code> Corresponding linear response vectors requests  Number of excited states requested</p>"},{"location":"API/app/responses_handler/stdl_responses_handler_/#nlrvreqs","title":"nlrvreqs","text":"<p>size_t nlrvreqs</p> <p><code>double[nops]</code>,  (in MO basis)  Number of LRV requests"},{"location":"API/app/responses_handler/stdl_responses_handler_/#nops","title":"nops","text":"<p>size_t nops</p> <p>Number of operators</p>"},{"location":"API/app/responses_handler/stdl_responses_handler_/#ops","title":"ops","text":"<p>stdl_operator* ops</p> <p><code>stdl_operator[nops]</code> list of operators</p>"},{"location":"API/app/user_input_handler/","title":"User input handler","text":"<p>Deals with all user inputs and convert that into requests.</p> <pre><code>#include \"user_input_handler.h\"\n</code></pre>"},{"location":"API/app/user_input_handler/#types","title":"Types","text":"Name Description stdl_method_ Method to select CSFs and build A/B matrices stdl_source_type_ Type of input for wavefunction &amp; basis set stdl_user_input_handler_ User input structure"},{"location":"API/app/user_input_handler/#functions","title":"Functions","text":"Name Description stdl_user_input_handler_check Check that the user input is correct. stdl_user_input_handler_compute_properties Compute (and display) the properties requested by the user. stdl_user_input_handler_delete Delete handler  Parameter <code>inp</code> :    a valid user input structure  Return :    error code stdl_user_input_handler_fill_from_args Change user input from program arguments. stdl_user_input_handler_fill_from_toml Change user input from options found in a TOML-formatted file. stdl_user_input_handler_log Print (through <code>stdl_log_msg()</code>) the user input, as a TOML-compatible. stdl_user_input_handler_make_context Create context from user input. stdl_user_input_handler_new Create an empty user input structure with default parameters. stdl_user_input_handler_new_from_args Helper function to create user input directly from program input. stdl_user_input_handler_parse_frequency Parse frequency given a a string of the form <code>NUMBER UNIT</code>, where <code>NUMBER</code> is a valid <code>double</code> and <code>UNIT</code> is either nothing (atomic units are assumed), <code>au</code>, <code>eV</code> or <code>nm</code>. stdl_user_input_handler_prepare_responses Prepare response calculations by creating a handler."},{"location":"API/app/user_input_handler/#function-details","title":"Function Details","text":""},{"location":"API/app/user_input_handler/#stdl_user_input_handler_check","title":"stdl_user_input_handler_check","text":"<p>int stdl_user_input_handler_check(stdl_user_input_handler* inp)</p> <p>Check that the user input is correct.</p> Parameter <code>inp</code> a valid user input structure Return error code"},{"location":"API/app/user_input_handler/#stdl_user_input_handler_compute_properties","title":"stdl_user_input_handler_compute_properties","text":"<p>int stdl_user_input_handler_compute_properties(stdl_user_input_handler* inp, stdl_context* ctx, stdl_responses_handler* rh)</p> <p>Compute (and display) the properties requested by the user.</p> Parameter <code>inp</code> a valid user input Parameter <code>ctx</code> a valid context Parameter <code>rh</code> a valid responses handler, with all responses computed Return error code"},{"location":"API/app/user_input_handler/#stdl_user_input_handler_delete","title":"stdl_user_input_handler_delete","text":"<p>int stdl_user_input_handler_delete(stdl_user_input_handler* inp)</p> <p>Delete handler</p> Parameter <code>inp</code> a valid user input structure Return error code"},{"location":"API/app/user_input_handler/#stdl_user_input_handler_fill_from_args","title":"stdl_user_input_handler_fill_from_args","text":"<p>int stdl_user_input_handler_fill_from_args(stdl_user_input_handler* inp, int argc, char* argv[])</p> <p>Change user input from program arguments. If the <code>&lt;file&gt;</code> argument is set, this implies a call to <code>stdl_user_input_handler_fill_from_toml()</code>.</p> Parameter <code>inp</code> a valid user input structure Parameter <code>argc</code> number of arguments Parameter <code>argv</code> actual arguments Return error code"},{"location":"API/app/user_input_handler/#stdl_user_input_handler_fill_from_toml","title":"stdl_user_input_handler_fill_from_toml","text":"<p>int stdl_user_input_handler_fill_from_toml(stdl_user_input_handler* inp, FILE *f)</p> <p>Change user input from options found in a TOML-formatted file.</p> Parameter <code>inp</code> a valid user input structure Parameter <code>f</code> path to a TOML file Return error code"},{"location":"API/app/user_input_handler/#stdl_user_input_handler_log","title":"stdl_user_input_handler_log","text":"<p>int stdl_user_input_handler_log(stdl_user_input_handler* inp)</p> <p>Print (through <code>stdl_log_msg()</code>) the user input, as a TOML-compatible.</p> Parameter <code>inp</code> a valid user input structure Return error code"},{"location":"API/app/user_input_handler/#stdl_user_input_handler_make_context","title":"stdl_user_input_handler_make_context","text":"<p>int stdl_user_input_handler_make_context(stdl_user_input_handler* inp, stdl_context **ctx_ptr)</p> <p>Create context from user input.</p> Parameter <code>inp</code> a valid user input Parameter <code>ctx_ptr</code> context to be created Return error code"},{"location":"API/app/user_input_handler/#stdl_user_input_handler_new","title":"stdl_user_input_handler_new","text":"<p>int stdl_user_input_handler_new(stdl_user_input_handler** inp_ptr)</p> <p>Create an empty user input structure with default parameters.</p> Parameter <code>inp_ptr</code> resulting structure Return error code"},{"location":"API/app/user_input_handler/#stdl_user_input_handler_new_from_args","title":"stdl_user_input_handler_new_from_args","text":"<p>int stdl_user_input_handler_new_from_args(int argc, char* argv[], stdl_user_input_handler** inp)</p> <p>Helper function to create user input directly from program input.</p> Parameter <code>argc</code> number of arguments Parameter <code>argv</code> arguments Parameter <code>inp</code> Return error code"},{"location":"API/app/user_input_handler/#stdl_user_input_handler_parse_frequency","title":"stdl_user_input_handler_parse_frequency","text":"<p>int stdl_user_input_handler_parse_frequency(char* input, double* result)</p> <p>Parse frequency given a a string of the form <code>NUMBER UNIT</code>, where <code>NUMBER</code> is a valid <code>double</code> and <code>UNIT</code> is either nothing (atomic units are assumed), <code>au</code>, <code>eV</code> or <code>nm</code>. The result is in atomic units.</p> Parameter <code>input</code> a valid <code>\\0</code>-terminated string Parameter <code>result</code> the resulting frequency in atomic unit, if any Return error code"},{"location":"API/app/user_input_handler/#stdl_user_input_handler_prepare_responses","title":"stdl_user_input_handler_prepare_responses","text":"<p>int stdl_user_input_handler_prepare_responses(stdl_user_input_handler *inp, stdl_context *ctx, stdl_responses_handler **rh_ptr)</p> <p>Prepare response calculations by creating a handler.</p> Parameter <code>inp</code> a valid user input Parameter <code>ctx</code> a valid context Parameter <code>rh_ptr</code> resulting responses handler Return error code"},{"location":"API/app/user_input_handler/stdl_method_/","title":"stdl_method_","text":"<p>enum stdl_method_</p> <p>Method to select CSFs and build A/B matrices</p> STDL_METHOD_MONOPOLE Monopole approximation STDL_METHOD_MONOPOLE_DIRECT Monopole approximation, direct calculation"},{"location":"API/app/user_input_handler/stdl_source_type_/","title":"stdl_source_type_","text":"<p>enum stdl_source_type_</p> <p>Type of input for wavefunction &amp; basis set</p>"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/","title":"stdl_user_input_handler_","text":"<p>struct stdl_user_input_handler_</p> <p>User input structure</p>"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#variables","title":"Variables","text":"Name Description title Title ctx_source Source path ctx_source_type Source type data_output H5 file output ctx_method Method ctx_tda Use the Tamm-Dancoff approximation ctx_gammaJ gammaJ for monopole approximation ctx_gammaK gammaK for monopole approximation ctx_ethr Energy threshold for MO and CSFs ctx_e2thr Perturbation energy threshold for secondary CSFs ctx_ax Amount of HF exchange res_resreqs Response requests"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#variable-details","title":"Variable Details","text":""},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#ctx_ax","title":"ctx_ax","text":"<p>float ctx_ax</p> <p>Amount of HF exchange</p>"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#ctx_e2thr","title":"ctx_e2thr","text":"<p>float ctx_e2thr</p> <p>Perturbation energy threshold for secondary CSFs</p>"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#ctx_ethr","title":"ctx_ethr","text":"<p>float ctx_ethr</p> <p>Energy threshold for MO and CSFs</p>"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#ctx_gammaj","title":"ctx_gammaJ","text":"<p>float ctx_gammaJ</p> <p>gammaJ for monopole approximation</p>"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#ctx_gammak","title":"ctx_gammaK","text":"<p>float ctx_gammaK</p> <p>gammaK for monopole approximation</p>"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#ctx_method","title":"ctx_method","text":"<p>stdl_method ctx_method</p> <p>Method</p>"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#ctx_source","title":"ctx_source","text":"<p>char* ctx_source</p> <p>Source path</p>"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#ctx_source_type","title":"ctx_source_type","text":"<p>stdl_source_type ctx_source_type</p> <p>Source type</p>"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#ctx_tda","title":"ctx_tda","text":"<p>int ctx_tda</p> <p>Use the Tamm-Dancoff approximation</p>"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#data_output","title":"data_output","text":"<p>char* data_output</p> <p>H5 file output</p>"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#res_resreqs","title":"res_resreqs","text":"<p>stdl_response_request* res_resreqs</p> <p>Response requests</p>"},{"location":"API/app/user_input_handler/stdl_user_input_handler_/#title","title":"title","text":"<p>char* title</p> <p>Title</p>"},{"location":"API/basis/","title":"Basis set","text":"<p>Describe a set of basis functions, centered on atoms. Also provide functions that computes expectation values (integrals) in AO basis.</p> <pre><code>#include &lt;stdlite/basis.h&gt;\n</code></pre> <p>Follows the structure of <code>libcint</code>, so that it can be used to compute extra integrals.</p> <p>Note</p> <p>Most of the documentation (and all examples) of libcint actually refers to the old (version &lt; 3.0) API. The new API actually includes two extra parameters described there. Furthermore, according to this, the first 20 values of <code>env</code> are reserved.</p> <p>Warning</p> <p>According to this comment, cartesian Gaussians are not (correctly) normalized by libcint. Thus every integral \\(\\braket{\\mu|\\hat A|\\nu}\\) between \\(\\mu\\) and \\(\\nu\\) (cartesian AOs) should be multiplied by a (re)normalization constant \\(N'_{\\mu\\nu} = N'_\\mu\\,N'_\\nu\\) with:</p> \\[N'_\\mu = \\frac{1}{\\sqrt{\\braket{\\mu|\\mu}}}.\\]"},{"location":"API/basis/#types","title":"Types","text":"Name Description stdl_basis_ Describe a set of basis functions, centered on atoms."},{"location":"API/basis/#functions","title":"Functions","text":"Name Description stdl_basis_delete Delete the basis set. stdl_basis_dsp_dipole Compute the electronic dipole matrix in AO basis, $D_{\\mu\\nu} = \\braket{\\mu stdl_basis_dsp_ovlp Compute the overlap matrix, $S_{\\mu\\nu} = \\braket{\\mu stdl_basis_dump_h5 Dump a basis in a H5 file  Parameter <code>bs</code> :    the wavefunction  Parameter <code>file_id</code> :    a valid H5 file_id identifier  Return :    error code stdl_basis_load_h5 Load a basis from a H5 file  Parameter <code>file_id</code> :    a valid H5 file_id identifier  Parameter <code>bs_ptr</code> :    the resulting wavefunction  Return :    error code stdl_basis_new Create a new basis set. stdl_basis_print Print the content of the basis set. stdl_basis_reorder_C Reorder the coefficients so that they match the one of libcint, using <code>transpose</code>."},{"location":"API/basis/#function-details","title":"Function Details","text":""},{"location":"API/basis/#stdl_basis_delete","title":"stdl_basis_delete","text":"<p>int stdl_basis_delete(stdl_basis* bs)</p> <p>Delete the basis set.</p> Parameter <code>bs</code> a valid basis set Return <code>STDL_ERR_OK</code>"},{"location":"API/basis/#stdl_basis_dsp_dipole","title":"stdl_basis_dsp_dipole","text":"<p>int stdl_basis_dsp_dipole(stdl_basis *bs, double *dipoles)</p> <p>Compute the electronic dipole matrix in AO basis, \\(D_{\\mu\\nu} = \\braket{\\mu|e\\,(\\hat r - R_0)|\\nu}\\).</p> Parameter <code>bs</code> a valid basis set Parameter <code>dipoles</code> <code>float[3, STDL_MATRIX_SP_SIZE(nao)]</code> the resulting dipole matrix. The component of the dipole is thus the slowest varying index. Return error code."},{"location":"API/basis/#stdl_basis_dsp_ovlp","title":"stdl_basis_dsp_ovlp","text":"<p>int stdl_basis_dsp_ovlp(stdl_basis *bs, double *S)</p> <p>Compute the overlap matrix, \\(S_{\\mu\\nu} = \\braket{\\mu|\\nu}\\) (double precision).</p> Parameter <code>bs</code> a valid basis set Parameter <code>S</code> <code>double[STDL_MATRIX_SP_SIZE(nao)]</code> the resulting overlap matrix. Return error code."},{"location":"API/basis/#stdl_basis_dump_h5","title":"stdl_basis_dump_h5","text":"<p>int stdl_basis_dump_h5(stdl_basis *bs, hid_t file_id)</p> <p>Dump a basis in a H5 file</p> Parameter <code>bs</code> the wavefunction Parameter <code>file_id</code> a valid H5 file_id identifier Return error code"},{"location":"API/basis/#stdl_basis_load_h5","title":"stdl_basis_load_h5","text":"<p>int stdl_basis_load_h5(hid_t file_id, stdl_basis **bs_ptr)</p> <p>Load a basis from a H5 file</p> Parameter <code>file_id</code> a valid H5 file_id identifier Parameter <code>bs_ptr</code> the resulting wavefunction Return error code"},{"location":"API/basis/#stdl_basis_new","title":"stdl_basis_new","text":"<p>int stdl_basis_new(int natm, int nbas, size_t env_size, int use_spherical, stdl_basis **bs_ptr)</p> <p>Create a new basis set. Initialize all the arrays.</p> <p>Warning</p> <p>According to this, the first 20 values of <code>env</code> are reserved. One should thus account for that when computing <code>env_size</code> (20 should be added to what is required) and when filling it (first 20th values should be zero, and the first non-zero value should be at <code>env[20]</code>).</p> Parameter <code>natm</code> Number of atoms Parameter <code>nbas</code> Number of basis functions Parameter <code>env_size</code> size of the <code>env</code> array, with <code>env_size &gt; 3*natm + 20</code>. Parameter <code>bs_ptr</code> Basis set object to be created. Return <code>STDL_ERR_OK</code> if everything went well."},{"location":"API/basis/#stdl_basis_print","title":"stdl_basis_print","text":"<p>int stdl_basis_print(stdl_basis *bs, int denormalize)</p> <p>Print the content of the basis set.</p> Parameter <code>bs</code> a valid basis set Parameter <code>denormalize</code> If set tpo 0, prints the actual coefficients stored in <code>env</code>. If not, prints without normalization. Return <code>STDL_ERR_OK</code>"},{"location":"API/basis/#stdl_basis_reorder_c","title":"stdl_basis_reorder_C","text":"<p>int stdl_basis_reorder_C(size_t nmo, size_t nao, double *C, stdl_basis *bs, size_t maxshell, int **transpose)</p> <p>Reorder the coefficients so that they match the one of libcint, using <code>transpose</code>.</p> Parameter <code>nmo</code> Number of MO, must be <code>nmo &lt;= nao</code> Parameter <code>nao</code> Number of AO must be &gt; 0. Parameter <code>C</code> <code>double[nmo*nao]</code>, the LCAO coefficients Parameter <code>bs</code> a valid basis Parameter <code>maxshell</code> the maximum shell that the transposition array contains Parameter <code>transpose</code> <code>int*[maxshells]</code>, an array of transpositions"},{"location":"API/basis/stdl_basis_/","title":"stdl_basis_","text":"<p>struct stdl_basis_</p> <p>Describe a set of basis functions, centered on atoms. Follows the structure of <code>libcint</code>, so that it can be used to compute extra integrals.</p>"},{"location":"API/basis/stdl_basis_/#variables","title":"Variables","text":"Name Description natm Number of atoms atm <code>int[natm*6]</code> list of atom. nbas Number of basis functions use_spherical Indicates that spherical functions should be assumed. bas <code>int[nbas*8]</code>, list of basis functions. env <code>double[env_size]</code>, array which stores the coordinates, GTO exponents, and contraction coefficients."},{"location":"API/basis/stdl_basis_/#variable-details","title":"Variable Details","text":""},{"location":"API/basis/stdl_basis_/#atm","title":"atm","text":"<p>int* atm</p> <p><code>int[natm*6]</code> list of atom.</p> <p>For each (ith) atom,</p> <ul> <li><code>atm[i*6+0]</code>: nuclear charge,</li> <li><code>atm[i*6+1]</code>: offset at which the coordinates are given in <code>env</code>,</li> <li>slots 2-5 are irrelevant</li> </ul>"},{"location":"API/basis/stdl_basis_/#bas","title":"bas","text":"<p>int* bas</p> <p><code>int[nbas*8]</code>, list of basis functions.</p> <p>For each (ith) basis function,</p> <ul> <li><code>bas[i*8+0]</code>: corresponding atom (0-based index)</li> <li><code>bas[i*8+1]</code>: angular momentum</li> <li><code>bas[i*8+2]</code>: number of primitive GTO, <code>nprim</code>,</li> <li><code>bas[i*8+3]</code>: number of contracted GTO, <code>ncont</code>,</li> <li><code>bas[i*8+4]</code>: not relevant here,</li> <li><code>bas[i*8+5]</code>: offset at which the <code>nprim</code> exponents of GTO are found in <code>env</code>,</li> <li><code>bas[i*8+6]</code>: offset at which the <code>nprim*ncont</code> contraction coefficients of GTO are found in <code>env</code>,</li> <li>slot 7 is irrelevant.</li> </ul>"},{"location":"API/basis/stdl_basis_/#env","title":"env","text":"<p>double* env</p> <p><code>double[env_size]</code>, array which stores the coordinates, GTO exponents, and contraction coefficients. In practice, the <code>natm*3</code> coordinates are stored first. Then for each basis function, the <code>nprim</code> exponents followed by the <code>nprim*ncont</code> coefficients are stored. For simplicity, each primitive should be normalized.</p>"},{"location":"API/basis/stdl_basis_/#natm","title":"natm","text":"<p>int natm</p> <p>Number of atoms</p>"},{"location":"API/basis/stdl_basis_/#nbas","title":"nbas","text":"<p>int nbas</p> <p>Number of basis functions</p>"},{"location":"API/basis/stdl_basis_/#use_spherical","title":"use_spherical","text":"<p>int use_spherical</p> <p>Indicates that spherical functions should be assumed.</p>"},{"location":"API/context/","title":"Context handler","text":"<p>Setup and modify a calculation.</p> <pre><code>#include &lt;stdlite/context.h&gt;\n</code></pre>"},{"location":"API/context/#types","title":"Types","text":"Name Description stdlite_context_ Object for the configuration and storage of intermediates of a sTD-DFT calculation."},{"location":"API/context/#functions","title":"Functions","text":"Name Description stdl_context_delete Delete a context. stdl_context_dump_h5 Dump a context in a H5 file  Parameter <code>ctx</code> :    a valid context  Parameter <code>file_id</code> :    a valid H5 file id, opened in write mode  Return :    error code stdl_context_load_h5 Load a context from a H5 file  Parameter <code>file_id</code> :    a valid H5 file id  Parameter <code>ctx_ptr</code> :    resulting context  Return :    error code stdl_context_new Create a new context. stdl_context_select_csfs_monopole Select CSFs and build the \\(\\mathbf A\\) and \\(\\mathbf B\\) matrices, using the monopole approximation (original sTD-DFT). stdl_context_select_csfs_monopole_direct Select CSFs and build the \\(\\mathbf A\\) and \\(\\mathbf B\\) matrices, using the monopole approximation (original sTD-DFT)."},{"location":"API/context/#function-details","title":"Function Details","text":""},{"location":"API/context/#stdl_context_delete","title":"stdl_context_delete","text":"<p>int stdl_context_delete(stdl_context* ctx)</p> <p>Delete a context. Also delete the <code>stdl_wavefunction</code> and <code>stdl_basis</code> that it contains.</p> Parameter <code>ctx</code> the context to be deleted Return error code"},{"location":"API/context/#stdl_context_dump_h5","title":"stdl_context_dump_h5","text":"<p>int stdl_context_dump_h5(stdl_context* ctx, hid_t file_id)</p> <p>Dump a context in a H5 file</p> Parameter <code>ctx</code> a valid context Parameter <code>file_id</code> a valid H5 file id, opened in write mode Return error code"},{"location":"API/context/#stdl_context_load_h5","title":"stdl_context_load_h5","text":"<p>int stdl_context_load_h5(hid_t file_id, stdl_context** ctx_ptr)</p> <p>Load a context from a H5 file</p> Parameter <code>file_id</code> a valid H5 file id Parameter <code>ctx_ptr</code> resulting context Return error code"},{"location":"API/context/#stdl_context_new","title":"stdl_context_new","text":"<p>int stdl_context_new(stdl_wavefunction *wf, stdl_basis *bs, float gammaJ, float gammaK, float ethr, float e2thr, float ax, stdl_context **ctx_ptr)</p> <p>Create a new context. Based on the information provided as input, a subset of MO from the wavefunction is selected, following the selection rules of sTD-DFT.</p> Parameter <code>wf</code> A valid wavefunction. Parameter <code>gammaJ</code> parameter for Coulomb integrals approximation Parameter <code>gammaK</code> parameter for exchange integrals approximation Parameter <code>ethr</code> energy threshold for primary CSFs, must be &gt;0 Parameter <code>e2thr</code> energy threshold for secondary CSFs (selected pertubatively), must be &gt;0 Parameter <code>ax</code> amount of HF exchange Parameter <code>ctx_ptr</code> The context to be created. Return error code"},{"location":"API/context/#stdl_context_select_csfs_monopole","title":"stdl_context_select_csfs_monopole","text":"<p>int stdl_context_select_csfs_monopole(stdl_context *ctx, int compute_B)</p> <p>Select CSFs and build the \\(\\mathbf A\\) and \\(\\mathbf B\\) matrices, using the monopole approximation (original sTD-DFT). If <code>B</code> is set to <code>NULL</code>, then only \\(\\mathbf A\\) is filled (Tamm-Dancoff approximation).</p> Parameter <code>ctx</code> a valid context Parameter <code>nselected</code> number of CSFs that were selected. If equals to 0, then <code>csfs</code> and <code>A</code> are not initialized. Parameter <code>csfs</code> <code>size_t[nselected]</code>, the indices (<code>i*ctx-&gt;nvirt + a</code>) of each selected CSF <code>i\u2192a</code>, as <code>i = csfs[k] / ctx-&gt;nvirt; a = csfs[k] % ctx-&gt;nvirt</code>. They are sorted in increasing energy order, the energy being available at <code>A[k * nselected + k]</code>. Parameter <code>A</code> <code>float[STDL_MATRIX_SP_SIZE(nslected)]</code>, part of the electronic Hessian matrix, in <code>sp</code> format, to be created. Caller is responsible for free'ing it. Parameter <code>B</code> <code>float[STDL_MATRIX_SP_SIZE(nslected)]</code>, part of the electronic Hessian matrix, in <code>sp</code> format, to be created. Might be <code>NULL</code> if only <code>A</code> is required. If not, caller is responsible for free'ing it. Return error code"},{"location":"API/context/#stdl_context_select_csfs_monopole_direct","title":"stdl_context_select_csfs_monopole_direct","text":"<p>int stdl_context_select_csfs_monopole_direct(stdl_context *ctx, int compute_B)</p> <p>Select CSFs and build the \\(\\mathbf A\\) and \\(\\mathbf B\\) matrices, using the monopole approximation (original sTD-DFT). If <code>B</code> is set to <code>NULL</code>, then only \\(\\mathbf A\\) is filled (Tamm-Dancoff approximation). Use less memory but takes more time than the non-direct version.</p> Parameter <code>ctx</code> a valid context Parameter <code>nselected</code> number of CSFs that were selected. If equals to 0, then <code>csfs</code> and <code>A</code> are not initialized. Parameter <code>csfs</code> <code>size_t[nselected]</code>, the indices (<code>i*ctx-&gt;nvirt + a</code>) of each selected CSF <code>i\u2192a</code>, as <code>i = csfs[k] / ctx-&gt;nvirt; a = csfs[k] % ctx-&gt;nvirt</code>. They are sorted in increasing energy order, the energy being available at <code>A[k * nselected + k]</code>. Parameter <code>A</code> <code>float[STDL_MATRIX_SP_SIZE(nslected)]</code>, part of the electronic Hessian matrix, in <code>sp</code> format, to be created. Caller is responsible for free'ing it. Parameter <code>B</code> <code>float[STDL_MATRIX_SP_SIZE(nslected)]</code>, part of the electronic Hessian matrix, in <code>sp</code> format, to be created. Might be <code>NULL</code> if only <code>A</code> is required. If not, caller is responsible for free'ing it. Return error code"},{"location":"API/context/stdlite_context_/","title":"stdlite_context_","text":"<p>struct stdlite_context_</p> <p>Object for the configuration and storage of intermediates of a sTD-DFT calculation. Contains a subset of MOs from <code>original_wf</code>.</p>"},{"location":"API/context/stdlite_context_/#variables","title":"Variables","text":"Name Description original_wf Input wavefunction bs Input basis set gammaJ Parameter for the method: \\(\\gamma_J\\). gammaK Parameter for the method: \\(\\gamma_K\\). ethr Parameter for the method: \\(E_{thr}\\), the threshold for selecting MOs and primary CSFs. e2thr Parameter for the method: \\(E^{(2)}_{thr}\\), the threshold for (perturbatively) selecting secondary CSFs. ax Parameter for the method: \\(a_x\\), the amount of HF exchange. nmo Number of MO considered in the calculation, so that <code>nmo &lt;= original_wf-&gt;nmo &amp;&amp; nocc + nvirt == nmo</code>. nocc Number of occupied MO considered in the calculation, with <code>nocc &lt; nmo &amp;&amp; nocc + nvirt == nmo</code> e_ptr pointer to the energies for the selected MOs C_ptr pointer to the (non orthogonal) MO coefficient for the selected MO C <code>double[nmo*original_wf-&gt;nao]</code> orthogonal MO coefficients for the selected MO. ncsfs number of CSFs selected by a given scheme (monopole, . csfs <code>size_t[ncsfs]</code>, the indices (<code>kia = i * nvirt + a - nocc</code>) of each selected CSF <code>i\u2192a</code> (as <code>i = csfs[kia] / nvirt; a = csfs[kia] % nvirt + nocc</code>). A <code>float[STDL_MATRIX_SP_SIZE(ncfs)]</code>, part of the electronic Hessian matrix. B <code>float[STDL_MATRIX_SP_SIZE(ncfs)]</code>, part of the electronic Hessian matrix."},{"location":"API/context/stdlite_context_/#variable-details","title":"Variable Details","text":""},{"location":"API/context/stdlite_context_/#a","title":"A","text":"<p>float* A</p> <p><code>float[STDL_MATRIX_SP_SIZE(ncfs)]</code>, part of the electronic Hessian matrix. <code>NULL</code> as long as no CSFs has been selected.</p>"},{"location":"API/context/stdlite_context_/#b","title":"B","text":"<p>float* B</p> <p><code>float[STDL_MATRIX_SP_SIZE(ncfs)]</code>, part of the electronic Hessian matrix. Might be <code>NULL</code> if only <code>A</code> is required.</p>"},{"location":"API/context/stdlite_context_/#c","title":"C","text":"<p>double* C</p> <p><code>double[nmo*original_wf-&gt;nao]</code> orthogonal MO coefficients for the selected MO.</p>"},{"location":"API/context/stdlite_context_/#c_ptr","title":"C_ptr","text":"<p>double* C_ptr</p> <p>pointer to the (non orthogonal) MO coefficient for the selected MO</p>"},{"location":"API/context/stdlite_context_/#ax","title":"ax","text":"<p>float ax</p> <p>Parameter for the method: \\(a_x\\), the amount of HF exchange.</p>"},{"location":"API/context/stdlite_context_/#bs","title":"bs","text":"<p>stdl_basis* bs</p> <p>Input basis set</p>"},{"location":"API/context/stdlite_context_/#csfs","title":"csfs","text":"<p>size_t* csfs</p> <p><code>size_t[ncsfs]</code>, the indices (<code>kia = i * nvirt + a - nocc</code>) of each selected CSF <code>i\u2192a</code> (as <code>i = csfs[kia] / nvirt; a = csfs[kia] % nvirt + nocc</code>).  They are given in increasing energy order, the energy being available at <code>ecsfs[kia]</code>.  <code>NULL</code> as long as no CSFs has been selected.</p>"},{"location":"API/context/stdlite_context_/#e2thr","title":"e2thr","text":"<p>float e2thr</p> <p>Parameter for the method: \\(E^{(2)}_{thr}\\), the threshold for (perturbatively) selecting secondary CSFs.</p>"},{"location":"API/context/stdlite_context_/#e_ptr","title":"e_ptr","text":"<p>double* e_ptr</p> <p>pointer to the energies for the selected MOs</p>"},{"location":"API/context/stdlite_context_/#ethr","title":"ethr","text":"<p>float ethr</p> <p>Parameter for the method: \\(E_{thr}\\), the threshold for selecting MOs and primary CSFs.</p>"},{"location":"API/context/stdlite_context_/#gammaj","title":"gammaJ","text":"<p>float gammaJ</p> <p>Parameter for the method: \\(\\gamma_J\\).</p>"},{"location":"API/context/stdlite_context_/#gammak","title":"gammaK","text":"<p>float gammaK</p> <p>Parameter for the method: \\(\\gamma_K\\).</p>"},{"location":"API/context/stdlite_context_/#ncsfs","title":"ncsfs","text":"<p>size_t ncsfs</p> <p>number of CSFs selected by a given scheme (monopole, ...). Zero as long as no CSFs has been selected.</p>"},{"location":"API/context/stdlite_context_/#nmo","title":"nmo","text":"<p>size_t nmo</p> <p>Number of MO considered in the calculation, so that <code>nmo &lt;= original_wf-&gt;nmo &amp;&amp; nocc + nvirt == nmo</code>.</p>"},{"location":"API/context/stdlite_context_/#nocc","title":"nocc","text":"<p>size_t nocc</p> <p>Number of occupied MO considered in the calculation, with <code>nocc &lt; nmo &amp;&amp; nocc + nvirt == nmo</code></p>"},{"location":"API/context/stdlite_context_/#original_wf","title":"original_wf","text":"<p>stdl_wavefunction* original_wf</p> <p>Input wavefunction</p>"},{"location":"API/helpers/","title":"Helpers functions and macros","text":"<p>Helpers functions and macros.</p> <pre><code>#include &lt;stdlite/helpers.h&gt;\n</code></pre>"},{"location":"API/helpers/#macros","title":"Macros","text":"Name Description STDL_APPLY Apply a function on a list of objects. STDL_CONST_AU_TO_ANG Conversion to Angstrom STDL_CONST_AU_TO_EV Conversion to eV STDL_CONST_HC Conversion to nanometers STDL_FREE_ALL Free all objects if they are non-<code>NULL</code>. STDL_FREE_IF_USED Free <code>a</code> if not <code>NULL</code>"},{"location":"API/helpers/#macro-details","title":"Macro Details","text":""},{"location":"API/helpers/#stdl_apply","title":"STDL_APPLY","text":"<p>#define STDL_APPLY(type, fn, ...)</p> <p>Apply a function on a list of objects. From B. Klemens in 21st century C (O'Reilly).</p>"},{"location":"API/helpers/#stdl_const_au_to_ang","title":"STDL_CONST_AU_TO_ANG","text":"<p>#define STDL_CONST_AU_TO_ANG</p> <p>Conversion to Angstrom</p>"},{"location":"API/helpers/#stdl_const_au_to_ev","title":"STDL_CONST_AU_TO_EV","text":"<p>#define STDL_CONST_AU_TO_EV</p> <p>Conversion to eV</p>"},{"location":"API/helpers/#stdl_const_hc","title":"STDL_CONST_HC","text":"<p>#define STDL_CONST_HC</p> <p>Conversion to nanometers</p>"},{"location":"API/helpers/#stdl_free_all","title":"STDL_FREE_ALL","text":"<p>#define STDL_FREE_ALL(...)</p> <p>Free all objects if they are non-<code>NULL</code>.</p>"},{"location":"API/helpers/#stdl_free_if_used","title":"STDL_FREE_IF_USED","text":"<p>#define STDL_FREE_IF_USED(a)</p> <p>Free <code>a</code> if not <code>NULL</code></p>"},{"location":"API/logging/","title":"Logging and errors","text":"<p>Handling of log, of errors, and of error messages.</p> <pre><code>#include &lt;stdlite/logging.h&gt;\n</code></pre> <p>Also contains function to signal warnings and debug messages.</p> <p>By default <code>DEBUG_LVL=1 &amp;&amp; LOG_LVL = 1</code>, which allows logs, errors and warnings to be printed.  To shut down every messages, use <code>stdl_set_debug_level(-1); stdl_set_log_level(-1);</code>.</p>"},{"location":"API/logging/#types","title":"Types","text":"Name Description stdl_error_code_ Enum for the errors codes."},{"location":"API/logging/#macros","title":"Macros","text":"Name Description STDL_DEBUG Print a debug message STDL_ERROR_CODE_HANDLE Handle error code (if different from <code>STDL_ERR_OK</code>) by using an action. STDL_ERROR_HANDLE Handle error (if <code>assertion</code> is true) by using an action. STDL_ERROR_HANDLE_AND_REPORT Handle error (if <code>assertion</code> is true) by printing a message and using an action. STDL_WARN Print a warning message"},{"location":"API/logging/#functions","title":"Functions","text":"Name Description stdl_debug_msg Print a debug message in <code>stdout</code>, if <code>DEBUG_LVL</code> is above 1. stdl_error_msg Print an error message in <code>stderr</code>, if <code>DEBUG_LVL</code> is equal or above 0. stdl_get_debug_level Get the value of <code>DEBUG_LVL</code> (default is 1). stdl_get_log_level Get the value of <code>LOG_LVL</code> (default is 1). stdl_library_build_commit Get library build commit  Return :    version stdl_library_build_date Get library build info  Return :    version stdl_library_name Get library name  Return :    name stdl_library_version Get library version  Return :    version stdl_log_msg Print a log message in <code>stdout</code> if <code>loglevel &gt;= LOG_LVL</code>. stdl_set_debug_level Set <code>DEBUG_LVL</code>. stdl_set_log_level Set <code>LOG_LVL</code>. stdl_warning_msg Print a warning message in <code>stdout</code>, if <code>DEBUG_LVL</code> is above 0."},{"location":"API/logging/#macro-details","title":"Macro Details","text":""},{"location":"API/logging/#stdl_debug","title":"STDL_DEBUG","text":"<p>#define STDL_DEBUG(...)</p> <p>Print a debug message</p>"},{"location":"API/logging/#stdl_error_code_handle","title":"STDL_ERROR_CODE_HANDLE","text":"<p>#define STDL_ERROR_CODE_HANDLE(code, error_action)</p> <p>Handle error code (if different from <code>STDL_ERR_OK</code>) by using an action.</p>"},{"location":"API/logging/#stdl_error_handle","title":"STDL_ERROR_HANDLE","text":"<p>#define STDL_ERROR_HANDLE(assertion, error_action)</p> <p>Handle error (if <code>assertion</code> is true) by using an action.</p>"},{"location":"API/logging/#stdl_error_handle_and_report","title":"STDL_ERROR_HANDLE_AND_REPORT","text":"<p>#define STDL_ERROR_HANDLE_AND_REPORT(assertion, error_action, ...)   \\</p> <p>Handle error (if <code>assertion</code> is true) by printing a message and using an action.  Inspired by B. Klemens in 21st century C (O'Reilly).</p>"},{"location":"API/logging/#stdl_warn","title":"STDL_WARN","text":"<p>#define STDL_WARN(...)</p> <p>Print a warning message</p>"},{"location":"API/logging/#function-details","title":"Function Details","text":""},{"location":"API/logging/#stdl_debug_msg","title":"stdl_debug_msg","text":"<p>void stdl_debug_msg(char *file, int line, char *format, ...)</p> <p>Print a debug message in <code>stdout</code>, if <code>DEBUG_LVL</code> is above 1.</p> Parameter <code>file</code> source file (use <code>__FILE__</code>) Parameter <code>line</code> line (use <code>__LINE__</code>) Parameter <code>format</code> format of the string Parameter <code>extra</code> parameters"},{"location":"API/logging/#stdl_error_msg","title":"stdl_error_msg","text":"<p>void stdl_error_msg(char *file, int line, char *format, ...)</p> <p>Print an error message in <code>stderr</code>, if <code>DEBUG_LVL</code> is equal or above 0.</p> Parameter <code>file</code> source file (use <code>__FILE__</code>) Parameter <code>line</code> line (use <code>__LINE__</code>) Parameter <code>format</code> format of the string Parameter <code>extra</code> parameters"},{"location":"API/logging/#stdl_get_debug_level","title":"stdl_get_debug_level","text":"<p>int stdl_get_debug_level()</p> <p>Get the value of <code>DEBUG_LVL</code> (default is 1).</p> Return the debug level"},{"location":"API/logging/#stdl_get_log_level","title":"stdl_get_log_level","text":"<p>int stdl_get_log_level()</p> <p>Get the value of <code>LOG_LVL</code> (default is 1).</p> Return the log level"},{"location":"API/logging/#stdl_library_build_commit","title":"stdl_library_build_commit","text":"<p>char* stdl_library_build_commit()</p> <p>Get library build commit</p> Return version"},{"location":"API/logging/#stdl_library_build_date","title":"stdl_library_build_date","text":"<p>char* stdl_library_build_date()</p> <p>Get library build info</p> Return version"},{"location":"API/logging/#stdl_library_name","title":"stdl_library_name","text":"<p>char* stdl_library_name()</p> <p>Get library name</p> Return name"},{"location":"API/logging/#stdl_library_version","title":"stdl_library_version","text":"<p>char* stdl_library_version()</p> <p>Get library version</p> Return version"},{"location":"API/logging/#stdl_log_msg","title":"stdl_log_msg","text":"<p>void stdl_log_msg(int loglevel, char *format, ...)</p> <p>Print a log message in <code>stdout</code> if <code>loglevel &gt;= LOG_LVL</code>.</p> Parameter <code>loglevel</code> logging level of the messafe Parameter <code>format</code> format of the string Parameter <code>extra</code> parameters"},{"location":"API/logging/#stdl_set_debug_level","title":"stdl_set_debug_level","text":"<p>void stdl_set_debug_level(const int level)</p> <p>Set <code>DEBUG_LVL</code>.</p> Parameter <code>level</code> any number, the larger the more messages one get. Setting this number to any negative totally shut down any message."},{"location":"API/logging/#stdl_set_log_level","title":"stdl_set_log_level","text":"<p>void stdl_set_log_level(const int level)</p> <p>Set <code>LOG_LVL</code>.</p> Parameter <code>level</code> any number, the larger the more messages one get. Setting this number to any negative totally shut down any message."},{"location":"API/logging/#stdl_warning_msg","title":"stdl_warning_msg","text":"<p>void stdl_warning_msg(char *file, int line, char *format, ...)</p> <p>Print a warning message in <code>stdout</code>, if <code>DEBUG_LVL</code> is above 0.</p> Parameter <code>file</code> source file (use <code>__FILE__</code>) Parameter <code>line</code> line (use <code>__LINE__</code>) Parameter <code>format</code> format of the string Parameter <code>extra</code> parameters"},{"location":"API/logging/stdl_error_code_/","title":"stdl_error_code_","text":"<p>enum stdl_error_code_</p> <p>Enum for the errors codes.</p> STDL_ERR_OK = 0 Everything went well STDL_ERR_MALLOC = 1 <code>malloc()</code> failure STDL_ERR_OPEN = 2 Open error STDL_ERR_READ = 3 Read error STDL_ERR_WRITE = 4 Write error STDL_ERR_INPUT = 5 Input error STDL_ERR_CONTEXT = 6 error in context STDL_ERR_UTIL_LEXER = 11 Error in the <code>lexer</code> module STDL_ERR_UTIL_PARSER = 12 Error in the <code>base_parser</code> module STDL_ERR_UTIL_FCHK = 13 Error in the <code>fchk_parser</code> module STDL_ERR_UTIL_MOLDEN = 14 Error in the <code>molden_parser</code> module STDL_ERR_BASIS = 15 Error in the <code>basis</code> module STDL_ERR_RESPONSE = 16 Error in the <code>response</code> module"},{"location":"API/property/","title":"Properties","text":"<p>Use the linear response vectors to compute some properties.</p> <pre><code>#include &lt;stdlite/property.h&gt;\n</code></pre>"},{"location":"API/property/#functions","title":"Functions","text":"Name Description stdl_property_e2e_transition_dipoles Evaluate the transition dipole/fluctuation operator between two excited states, $\\braket{u stdl_property_first_hyperpolarizability Compute the hyperpolarizability \\(\\beta(-\\omega_\\sigma;\\omega_1,\\omega_2)\\) tensor elements. Use intrinsic permutations to alleviate some costs if possible. !!! note Since permutations relies on the addresses of the response vectors, the same \\(\\mathbf x(\\omega)\\) (and \\(\\mathbf y(\\omega)\\)) should be used if some frequencies are the same (e.g., for a static calculation, the input for <code>Xs</code> should be <code>(float*[]) {Xs, Xs, Xs}</code>).  Parameter <code>ctx</code> :    a valid context, with <code>ctx-&gt;ncsfs &gt; 0</code>.  Parameter <code>dips_MO</code> :    <code>float[3,STDL_MATRIX_SP_SIZE(ctx-&gt;nmo)]</code>, the dipole moment matrix, in MO basis.  Parameter <code>Xs</code> :    <code>float*[3]</code> the 3 linear response vectors corresponding to \\(\\mathbf x(-\\omega_\\sigma)\\), \\(\\mathbf x(\\omega_1)\\), and \\(\\mathbf x(\\omega_2)\\).  Parameter <code>Ys</code> :    <code>float*[3]</code> the 3 linear response vectors corresponding to \\(\\mathbf y(-\\omega_\\sigma)\\), \\(\\mathbf y(\\omega_1)\\), and \\(\\mathbf y(\\omega_2)\\).  Parameter <code>beta</code> :    <code>float[3,3,3]</code> the hyperpolarizability tensor  Return :    error code stdl_property_polarizability Compute the polarizability \\(\\alpha(-\\omega;\\omega)\\) tensor elements.  Parameter <code>ctx</code> :    a valid context, with <code>ctx-&gt;ncsfs &gt; 0</code>.  Parameter <code>dips_MO</code> :    <code>float[3,STDL_MATRIX_SP_SIZE(ctx-&gt;nmo)]</code>, the dipole moment matrix, in MO basis.  Parameter <code>X</code> :    <code>float[ncsfs,3]</code> linear response vector  Parameter <code>Y</code> :    <code>float[ncsfs,3]</code> linear response vector.  Parameter <code>alpha</code> :    <code>float[STDL_MATRIX_SP_SIZE(3)]</code> the polarizability tensor  Return :    error code stdl_property_transition_dipoles Compute the transition dipoles."},{"location":"API/property/#function-details","title":"Function Details","text":""},{"location":"API/property/#stdl_property_e2e_transition_dipoles","title":"stdl_property_e2e_transition_dipoles","text":"<p>int stdl_property_e2e_transition_dipoles(stdl_context* ctx, size_t nexci, double* dips_MO, float * X, float * Y, float* e2etdips)</p> <p>Evaluate the transition dipole/fluctuation operator between two excited states, \\(\\braket{u|\\hat\\mu_\\zeta - \\delta_{uv}\\,\\braket{0|\\hat\\mu_\\zeta|0}|v}\\).</p> Parameter <code>ctx</code> a valid context, with <code>ctx-&gt;ncsfs &gt; 0</code>. Parameter <code>nexci</code> number of excitations computed Parameter <code>dips_MO</code> <code>float[3,STDL_MATRIX_SP_SIZE(ctx-&gt;nmo)]</code>, the dipole moment matrix, in MO basis. Parameter <code>X</code> <code>float[nexci,ncsfs]</code> amplitude vector \\(\\mathbf x\\) Parameter <code>Y</code> <code>float[nexci,ncsfs]</code> amplitude vector \\(\\mathbf y\\), might be <code>NULL</code> if TDA. Parameter <code>e2etdips</code> <code>float[3,nexci,nexci]</code> the values of the different components of the transition dipoles. Return error code"},{"location":"API/property/#stdl_property_first_hyperpolarizability","title":"stdl_property_first_hyperpolarizability","text":"<p>int stdl_property_first_hyperpolarizability(stdl_context* ctx, double* dips_MO, float *Xs[3], float *Ys[3], float* beta)</p> <p>Compute the hyperpolarizability \\(\\beta(-\\omega_\\sigma;\\omega_1,\\omega_2)\\) tensor elements. Use intrinsic permutations to alleviate some costs if possible.</p> <p>Note</p> <p>Since permutations relies on the addresses of the response vectors, the same \\(\\mathbf x(\\omega)\\) (and \\(\\mathbf y(\\omega)\\)) should be used if some frequencies are the same (e.g., for a static calculation, the input for <code>Xs</code> should be <code>(float*[]) {Xs, Xs, Xs}</code>).</p> Parameter <code>ctx</code> a valid context, with <code>ctx-&gt;ncsfs &gt; 0</code>. Parameter <code>dips_MO</code> <code>float[3,STDL_MATRIX_SP_SIZE(ctx-&gt;nmo)]</code>, the dipole moment matrix, in MO basis. Parameter <code>Xs</code> <code>float*[3]</code> the 3 linear response vectors corresponding to \\(\\mathbf x(-\\omega_\\sigma)\\), \\(\\mathbf x(\\omega_1)\\), and \\(\\mathbf x(\\omega_2)\\). Parameter <code>Ys</code> <code>float*[3]</code> the 3 linear response vectors corresponding to \\(\\mathbf y(-\\omega_\\sigma)\\), \\(\\mathbf y(\\omega_1)\\), and \\(\\mathbf y(\\omega_2)\\). Parameter <code>beta</code> <code>float[3,3,3]</code> the hyperpolarizability tensor Return error code"},{"location":"API/property/#stdl_property_polarizability","title":"stdl_property_polarizability","text":"<p>int stdl_property_polarizability(stdl_context* ctx, double* dips_MO, float* X, float* Y, float* alpha)</p> <p>Compute the polarizability \\(\\alpha(-\\omega;\\omega)\\) tensor elements.</p> Parameter <code>ctx</code> a valid context, with <code>ctx-&gt;ncsfs &gt; 0</code>. Parameter <code>dips_MO</code> <code>float[3,STDL_MATRIX_SP_SIZE(ctx-&gt;nmo)]</code>, the dipole moment matrix, in MO basis. Parameter <code>X</code> <code>float[ncsfs,3]</code> linear response vector Parameter <code>Y</code> <code>float[ncsfs,3]</code> linear response vector. Parameter <code>alpha</code> <code>float[STDL_MATRIX_SP_SIZE(3)]</code> the polarizability tensor Return error code"},{"location":"API/property/#stdl_property_transition_dipoles","title":"stdl_property_transition_dipoles","text":"<p>int stdl_property_transition_dipoles(stdl_context *ctx, size_t nexci, double* dips_MO, float* X, float* Y, float * tdips)</p> <p>Compute the transition dipoles.</p> Parameter <code>ctx</code> a valid context, with <code>ctx-&gt;ncsfs &gt; 0</code>. Parameter <code>nexci</code> number of excitations computed Parameter <code>dips_MO</code> <code>float[3,STDL_MATRIX_SP_SIZE(ctx-&gt;nmo)]</code>, the dipole moment matrix, in MO basis. Parameter <code>X</code> <code>float[nexci,ncsfs]</code> amplitude vector \\(\\mathbf x\\) Parameter <code>Y</code> <code>float[nexci,ncsfs]</code> amplitude vector \\(\\mathbf y\\), might be <code>NULL</code> if TDA. Parameter <code>tdips</code> <code>float[3,nexci]</code> the transition tdips Return error code"},{"location":"API/response/","title":"Response functions","text":"<p>Solve the linear response problem or the Casida equation.</p> <pre><code>#include &lt;stdlite/response.h&gt;\n</code></pre>"},{"location":"API/response/#macros","title":"Macros","text":"Name Description STDL_RESPONSE_EIGV_ABSTOL <code>ABSTOL</code> parameter for the precision of eigenvalue in bisect algorithms used by LAPACK."},{"location":"API/response/#functions","title":"Functions","text":"Name Description stdl_response_TDA_casida Solve the Casida equation to get excitation energies and amplitudes vectors (\\(\\mathbf x^m\\)) within the Tamm-Dancoff approximation. stdl_response_TDA_linear Solve the linear response equation at <code>nw</code> energies \\(\\{\\omega_i\\}\\), within the Tamm-Dancoff approximation, to get the corresponding response vectors (\\(\\mathbf x(\\omega_i)\\), \\(\\mathbf y(\\omega_i)\\)). stdl_response_TD_casida Solve the Casida equation to get excitation energies and their corresponding amplitude vectors (\\(\\mathbf x^m\\), \\(\\mathbf y^m\\)). stdl_response_TD_linear Solve the linear response equation at <code>nw</code> energies \\(\\{\\omega_i\\}\\)  to get the corresponding response vectors (\\(\\mathbf x(\\omega_i)\\), \\(\\mathbf y(\\omega_i)\\)). stdl_response_perturbed_gradient Create \\(-2\\eta\\), the perturbed electronic gradient matrix to be used in linear response equation (<code>stdl_response_TD_linear()</code>)."},{"location":"API/response/#macro-details","title":"Macro Details","text":""},{"location":"API/response/#stdl_response_eigv_abstol","title":"STDL_RESPONSE_EIGV_ABSTOL","text":"<p>#define STDL_RESPONSE_EIGV_ABSTOL</p> <p><code>ABSTOL</code> parameter for the precision of eigenvalue in bisect algorithms used by LAPACK.</p>"},{"location":"API/response/#function-details","title":"Function Details","text":""},{"location":"API/response/#stdl_response_tda_casida","title":"stdl_response_TDA_casida","text":"<p>int stdl_response_TDA_casida(stdl_context *ctx, size_t nexci, float *e, float *X)</p> <p>Solve the Casida equation to get excitation energies and amplitudes vectors (\\(\\mathbf x^m\\)) within the Tamm-Dancoff approximation. Only returns the first <code>nexci</code> first excitation energies. Works well if <code>nexci &lt;&lt; ncsfs</code>. The precision on the eigenvalues is given by <code>STDL_RESPONSE_EIGV_ABSTOL</code>.</p> Parameter <code>ctx</code> a valid context, with <code>ctx-&gt;ncsfs &gt; 0</code>. Parameter <code>nexci</code> number of excitations requested. Must be <code>0 &lt; nexci &lt;= ctx-&gt;ncsfs</code>. Parameter <code>e</code> <code>float[nexci]</code> excitation energies \\(\\omega_m\\) . Parameter <code>X</code> <code>float[nexci,ncsfs]</code> amplitudes vector, \\(\\mathbf x^m\\), for each excitation \\(\\ket{m}\\). Return error code"},{"location":"API/response/#stdl_response_tda_linear","title":"stdl_response_TDA_linear","text":"<p>int stdl_response_TDA_linear(stdl_context *ctx, size_t nw, float *w, size_t ndim, float *egrad, float *X, float *Y)</p> <p>Solve the linear response equation at <code>nw</code> energies \\(\\{\\omega_i\\}\\), within the Tamm-Dancoff approximation, to get the corresponding response vectors (\\(\\mathbf x(\\omega_i)\\), \\(\\mathbf y(\\omega_i)\\)).</p> Parameter <code>ctx</code> a valid context, with <code>ctx-&gt;ncsfs &gt; 0</code>. Parameter <code>nw</code> number of energies at which linear response should be computed Parameter <code>w</code> <code>float[nw]</code> energies at which linear response should be computed Parameter <code>ndim</code> dimension of the electronic gradient Parameter <code>egrad</code> <code>float[ncsfs,ndim]</code> \\(-2\\eta\\), the perturbed electronic gradient in each dimension. Parameter <code>X</code> <code>float[nw,ncsfs,ndim]</code> response vector \\(\\mathbf x(\\omega)\\), in each dimension. Parameter <code>Y</code> <code>float[nw,ncsfs,ndim]</code> response vector \\(\\mathbf y(\\omega)\\) in each dimension. Return error code"},{"location":"API/response/#stdl_response_td_casida","title":"stdl_response_TD_casida","text":"<p>int stdl_response_TD_casida(stdl_context *ctx, size_t nexci, float *e, float *X, float *Y)</p> <p>Solve the Casida equation to get excitation energies and their corresponding amplitude vectors (\\(\\mathbf x^m\\), \\(\\mathbf y^m\\)). Only returns the first <code>nexci</code> first excitation energies. Works well if <code>nexci &lt;&lt; ncsfs</code>. The precision on the eigenvalues is given by <code>STDL_RESPONSE_EIGV_ABSTOL</code>.</p> Parameter <code>ctx</code> a valid context, with <code>ctx-&gt;ncsfs &gt; 0 &amp;&amp; ctx-&gt;B != NULL</code>. Parameter <code>nexci</code> number of excitations requested. Must be <code>0 &lt; nexci &lt;= ctx-&gt;ncsfs</code>. Parameter <code>e</code> <code>float[nexci]</code> excitation energies. Parameter <code>X</code> <code>float[nexci,ncsfs]</code> amplitude vector \\(\\mathbf x^m\\) for each excitation \\(\\ket{m}\\). Parameter <code>Y</code> <code>float[nexci,ncsfs]</code> amplitude vector \\(\\mathbf y^m\\) for each excitation \\(\\ket{m}\\). Return error code"},{"location":"API/response/#stdl_response_td_linear","title":"stdl_response_TD_linear","text":"<p>int stdl_response_TD_linear(stdl_context *ctx, size_t nw, float *w, size_t ndim, float *egrad, float *X, float *Y)</p> <p>Solve the linear response equation at <code>nw</code> energies \\(\\{\\omega_i\\}\\)  to get the corresponding response vectors (\\(\\mathbf x(\\omega_i)\\), \\(\\mathbf y(\\omega_i)\\)).</p> Parameter <code>ctx</code> a valid context, with <code>ctx-&gt;ncsfs &gt; 0 &amp;&amp; ctx-&gt;B != NULL</code>. Parameter <code>nw</code> number of energies at which linear response should be computed Parameter <code>w</code> <code>float[nw]</code> energies at which linear response should be computed Parameter <code>ndim</code> dimension of the electronic gradient Parameter <code>egrad</code> <code>float[ncsfs,ndim]</code> \\(-2\\eta\\), the perturbed electronic gradient in each dimension. Parameter <code>X</code> <code>float[nw,ncsfs,ndim]</code> response vector \\(\\mathbf x(\\omega)\\), in each dimension. Parameter <code>Y</code> <code>float[nw,ncsfs,ndim]</code> response vector \\(\\mathbf y(\\omega)\\), in each dimension. Return error code"},{"location":"API/response/#stdl_response_perturbed_gradient","title":"stdl_response_perturbed_gradient","text":"<p>int stdl_response_perturbed_gradient(stdl_context* ctx, size_t dim, double* eta_MO, float *egrad)</p> <p>Create \\(-2\\eta\\), the perturbed electronic gradient matrix to be used in linear response equation (<code>stdl_response_TD_linear()</code>).</p> Parameter <code>ctx</code> a valid context, with <code>ctx-&gt;ncsfs &gt; 0</code>. Parameter <code>dim</code> dimension of the expectation value <code>eta_MO</code> Parameter <code>eta_MO</code> <code>double[dim,ctx-&gt;nmo,ctx-&gt;nmo]</code>, the value of \\(\\eta\\) in MO basis Parameter <code>egrad</code> <code>float[ctx-&gt;ncsfs,dim]</code> \\(-2\\eta\\), the resulting perturbed electronic gradient Return error code"},{"location":"API/utilities/","title":"Utilities","text":"<p>Utility functions, not directly required to use the library.</p> Lexer A character per character lexer, that assign types to certain kind of characters. Basic parser utilities Basic parser utilities to extract strings, integers, and real numbers from files. Experimental quantities Utilities to compute experimental quantities (generally from rotational averaging). FCHK parser Parser for the FCHK files generated by Gaussian. Matrices Utilities to work with matrices. MOLDEN file parser Parser for MOLDEN file, a common container of QM results that can be generated by (or, sometimes, from) a bunch of quantum chemistry programs. Permutations Deal with permutations."},{"location":"API/utilities/base_parser/","title":"Basic parser utilities","text":"<p>Basic parser utilities to extract strings, integers, and real numbers from files.</p> <pre><code>#include &lt;stdlite/utils/base_parser.h&gt;\n</code></pre>"},{"location":"API/utilities/base_parser/#macros","title":"Macros","text":"Name Description STDL_LEXER_ERROR_HAR Copycat of <code>STDL_ERROR_HANDLE_AND_REPORT</code>, but using the <code>stdl_error_msg_lexer</code> function instead. STDL_STR_MULT Multiplier for string growth."},{"location":"API/utilities/base_parser/#functions","title":"Functions","text":"Name Description stdl_error_msg_lexer Output a specific error message indicating the current token if <code>DEBUG_LVL</code> is above or equal to 0. stdl_grow_string Allocate a string, and grow it from time to time if its size (given by <code>sz</code>) gets too large. stdl_parser_get_integer Parse an integer, if any. stdl_parser_get_literal Put the stream of tokens in <code>result</code> as long as <code>predicate</code> is true. stdl_parser_get_number Parse a real number matching <code>(PLUS|DASH)? DIGIT* (DOT DIGIT*)? (('E'|'e') (PLUS|MINUS)* DIGIT*)?</code> (as a <code>double</code>), if any. stdl_parser_store_value_and_grow_string Store the current token value in a string, increase its size by 1, then grow it."},{"location":"API/utilities/base_parser/#macro-details","title":"Macro Details","text":""},{"location":"API/utilities/base_parser/#stdl_lexer_error_har","title":"STDL_LEXER_ERROR_HAR","text":"<p>#define STDL_LEXER_ERROR_HAR(lx, assertion, error_action, ...)       \\</p> <p>Copycat of <code>STDL_ERROR_HANDLE_AND_REPORT</code>, but using the <code>stdl_error_msg_lexer</code> function instead.</p>"},{"location":"API/utilities/base_parser/#stdl_str_mult","title":"STDL_STR_MULT","text":"<p>#define STDL_STR_MULT</p> <p>Multiplier for string growth.</p>"},{"location":"API/utilities/base_parser/#function-details","title":"Function Details","text":""},{"location":"API/utilities/base_parser/#stdl_error_msg_lexer","title":"stdl_error_msg_lexer","text":"<p>void stdl_error_msg_lexer(char *file, int line, stdl_lexer* lx, char *format, ...)</p> <p>Output a specific error message indicating the current token if <code>DEBUG_LVL</code> is above or equal to 0.</p> Parameter <code>file</code> source file (use <code>__FILE__</code>) Parameter <code>line</code> line (use <code>__LINE__</code>) Parameter <code>lx</code> a valid lexer Parameter <code>format</code> format of the string Parameter <code>extra</code> parameters"},{"location":"API/utilities/base_parser/#stdl_grow_string","title":"stdl_grow_string","text":"<p>int stdl_grow_string(char** str_ptr, int sz, int* fac)</p> <p>Allocate a string, and grow it from time to time if its size (given by <code>sz</code>) gets too large. Actually allocates <code>fac * STDL_STR_MULT</code> bytes, and increases <code>fac</code> by one each time the size gets too large.</p> Parameter <code>str_ptr</code> str_ptr pointer to a non-<code>NULL</code> string. Caller is responsible for free'ing it. Parameter <code>sz</code> current size of said string Parameter <code>fac</code> scaling factor, increase periodically. Set to 0 to initialize the string Return <code>STDL_ERR_OK</code> if everything went well."},{"location":"API/utilities/base_parser/#stdl_parser_get_integer","title":"stdl_parser_get_integer","text":"<p>int stdl_parser_get_integer(stdl_lexer* lx, long *result)</p> <p>Parse an integer, if any.</p> Parameter <code>lx</code> a valid lexer Parameter <code>result</code> the resulting integer if there was something to read Return <code>STDL_ERR_OK</code> if integer was read, <code>STDL_ERR_UTIL_PARSER</code> otherwise."},{"location":"API/utilities/base_parser/#stdl_parser_get_literal","title":"stdl_parser_get_literal","text":"<p>int stdl_parser_get_literal(stdl_lexer* lx, int (*predicate)(int), char** result)</p> <p>Put the stream of tokens in <code>result</code> as long as <code>predicate</code> is true.</p> Parameter <code>lx</code> a valid lexer Parameter <code>predicate</code> a predicate, called for each token, of the form <code>int predicate(int c)</code>, where <code>c</code> is the current token value. Parameter <code>result</code> the resulting string. Caller is responsible for free'ing it. Return <code>STDL_ERR_OK</code> if everything went well."},{"location":"API/utilities/base_parser/#stdl_parser_get_number","title":"stdl_parser_get_number","text":"<p>int stdl_parser_get_number(stdl_lexer* lx, double* result)</p> <p>Parse a real number matching <code>(PLUS|DASH)? DIGIT* (DOT DIGIT*)? (('E'|'e') (PLUS|MINUS)* DIGIT*)?</code> (as a <code>double</code>), if any.</p> Parameter <code>lx</code> a valid lexer Parameter <code>result</code> the resulting real number if there was something to read Return <code>STDL_ERR_OK</code> if real number was read, <code>STDL_ERR_UTIL_PARSER</code> otherwise."},{"location":"API/utilities/base_parser/#stdl_parser_store_value_and_grow_string","title":"stdl_parser_store_value_and_grow_string","text":"<p>int stdl_parser_store_value_and_grow_string(stdl_lexer* lx, char** str, int* sz, int* fac)</p> <p>Store the current token value in a string, increase its size by 1, then grow it. Also advance the lexer to the next token</p> Parameter <code>lx</code> a valid lexer Parameter <code>str</code> str pointer to a non-<code>NULL</code> string. Caller is responsible for free'ing it. Parameter <code>sz</code> size of said string. Parameter <code>fac</code> scaling factor, increase periodically. Return <code>STDL_ERR_OK</code> if everything went well."},{"location":"API/utilities/fchk_parser/","title":"FCHK parser","text":"<p>Parser for the FCHK files generated by Gaussian. FCHK stands for formatted checkpoint, for which the format is described in the \"FChk File\" tab of this page.</p> <pre><code>#include &lt;stdlite/utils/fchk_parser.h&gt;\n</code></pre> <p>While this parser contains a few safeguards, it works better if the FCHK is correctly formatted.</p> <p>Warning</p> <p>The logical type, <code>L</code>, is not implemented. However, it does not seem to be used in production FCHK. Scalar <code>C</code> is also not implemented nor used.</p> <p>The ordering of the orbitals for a given angular momentum is specific to Gaussian, but <code>stdlite</code> expects inputs and produce outputs following the order of <code>libcint</code>. The following transposition table is used for LCAO coefficients.</p> <p>For cartesian orbitals (<code>6d</code>, <code>10f</code>, <code>15g</code>, etc)</p> libcint (source) Gaussian (source) \\(s\\) \\(s\\) \\(p_x\\), \\(p_y\\), \\(p_z\\) \\(p_x\\), \\(p_y\\), \\(p_z\\) \\(d_{xx}\\) (0), \\(d_{xy}\\) (1), \\(d_{xz}\\) (2), \\(d_{yy}\\) (3), \\(d_{yz}\\) (4), \\(d_{zz}\\) (5) \\(d_{xx}\\) (0), \\(d_{yy}\\) (3), \\(d_{zz}\\) (5), \\(d_{xy}\\) (1), \\(d_{xz}\\) (2), \\(d_{yz}\\) (4) \\(f_{xxx}\\) (0), \\(f_{xxy}\\) (1), \\(f_{xxz}\\) (2), \\(f_{xyy}\\) (3), \\(f_{xyz}\\) (4), \\(f_{xzz}\\) (5), \\(f_{yyy}\\) (6), \\(f_{yyz}\\) (7), \\(f_{yzz}\\) (8), \\(f_{zzz}\\) (9) \\(f_{xxx}\\) (0), \\(f_{yyy}\\) (6), \\(f_{zzz}\\) (9), \\(f_{xyy}\\) (3), \\(f_{xxy}\\) (1), \\(f_{xxz}\\) (2), \\(f_{xzz}\\) (5), \\(f_{yzz}\\) (8), \\(f_{yyz}\\) (7), \\(f_{xyz}\\) (4) \\(g_{xxxx}\\) (0), \\(g_{xxxy}\\) (1), \\(g_{xxxz}\\) (2), \\(g_{xxyy}\\) (3), \\(g_{xxyz}\\) (4), \\(g_{xxzz}\\) (5), \\(g_{yyxz}\\) (6), \\(g_{yyyx}\\) (7), \\(g_{yyyy}\\) (8), \\(g_{yyyz}\\) (9), \\(g_{yyzz}\\) (10), \\(g_{zzxy}\\) (11), \\(g_{zzzx}\\) (12), \\(g_{zzzy}\\) (13), \\(g_{zzzz}\\) (14) \\(g_{xxxx}\\) (0), \\(g_{yyyy}\\) (8), \\(g_{zzzz}\\) (14), \\(g_{xxxy}\\) (1), \\(g_{xxxz}\\) (2), \\(g_{yyyx}\\) (7), \\(g_{yyyz}\\) (9), \\(g_{zzzx}\\) (12), \\(g_{zzzy}\\) (13), \\(g_{xxyy}\\) (3), \\(g_{xxzz}\\) (5), \\(g_{yyzz}\\) (10), \\(g_{xxyz}\\) (4), \\(g_{yyxz}\\) (6), \\(g_{zzxy}\\) (11) <p>For spherical orbitals (<code>5d</code>, <code>7f</code>, etc., see there for definition):</p> libcint (source) Gaussian (source) \\(d_{-2}\\) (0), \\(d_{-1}\\) (1), \\(d_0\\) (2), \\(d_1\\) (3), \\(d_2\\) (4) \\(d_0\\) (2), \\(d_1\\) (3), \\(d_{-1}\\) (1), \\(d_2\\) (4), \\(d_{-2}\\) (0) \\(f_{-3}\\) (0), \\(f_{-2}\\) (1), \\(f_{-1}\\) (2), \\(f_0\\) (3), \\(f_1\\) (4), \\(f_2\\) (5), \\(f_3\\) (6) \\(f_0\\) (3), \\(f_{1}\\) (4), \\(f_{-1}\\) (2), \\(f_{2}\\) (5), \\(f_{-2}\\) (1), \\(f_{3}\\) (6), \\(f_{-3}\\) (0) \\(g_{-4}\\) (0), \\(g_{-3}\\) (1), \\(g_{-2}\\) (2), \\(g_{-1}\\) (3), \\(g_0\\) (4), \\(g_1\\) (5), \\(g_2\\) (6), \\(g_3\\) (7), \\(g_4\\) (8) \\(g_0\\) (4), \\(g_1\\) (5), \\(g_{-1}\\) (3), \\(g_2\\) (6), \\(g_{-2}\\) (2), \\(g_3\\) (7), \\(g_{-3}\\) (1), \\(g_4\\) (8), \\(g_{-4}\\) (0) <p>Warning</p> <p>For the moment, only functions up to \\(g\\) are thus handled.</p> <p>In order to parse a FCHK, use something of the form:</p> <pre><code>char* name = NULL;\nchar type;\nint error, is_scalar;\n\n// 1. Open file, create lexer\nFILE* f = fopen(\"file.fchk\", \"r\");\nstdl_lexer* lx = stdl_lexer_new(f);\n\n// 2. Skip intro\nstdl_fchk_parser_skip_intro(lx);\n\n// 3. Read sections\nwhile (lx-&gt;current_tk_type != STDL_TK_EOF) {\n  // read section info, giving:\n  // a) the name of the section, b) its type, and c) if it is a scalar\n  error = stdl_fchk_parser_get_section_info(lx, &amp;name, &amp;type, &amp;is_scalar);\n\n  if(error == STDL_ERR_OK) {\n    if(strcmp(\"an interesting section\", name) == 0) {\n      /* Read the content of this section by using either:\n       * - `stdl_fchk_parser_get_scalar_*()`, or\n       * - `stdl_fchk_parser_get_vector_*()`.\n       * Don't forget to free the result after use.\n       */\n    } else if(/* ... */) {\n      /* ... */\n    } else {\n      // not interesting, skip section\n      stdl_fchk_parser_skip_section(lx, type, is_scalar);\n    }\n    free(name);\n  }\n}\n\nstdl_lexer_delete(lx);\nfclose(f);\n</code></pre>"},{"location":"API/utilities/fchk_parser/#types","title":"Types","text":"Name Description stdl_basis_data_ Transpose the LCAO coefficients from Gaussian 16 so that they match <code>libcint</code>, cartesian functions."},{"location":"API/utilities/fchk_parser/#functions","title":"Functions","text":"Name Description stdl_basis_data_count_nao Count the number of AO expected for a given basis  Parameter <code>dt</code> :    a valid pointer to data  Parameter <code>total</code> :    the number of AO  Return :    error code stdl_basis_data_delete Delete a basis set data holder. stdl_basis_data_new Create a new basis set data holder. stdl_basis_data_to_basis Convert a basis set data to an actual <code>stdl_basis</code>. stdl_fchk_parser_extract Extract a wavefunction (<code>stdl_wavefunction</code>) and a basis set (<code>stdl_basis</code>) from a FCHK file. stdl_fchk_parser_get_scalar_integer Parse a scalar integer. stdl_fchk_parser_get_scalar_number Parse a scalar real number. stdl_fchk_parser_get_section_info Parse the info of a section in FCHK. stdl_fchk_parser_get_vector_integers Parse a vector of integers in FCHK. stdl_fchk_parser_get_vector_integers_immediate Parse a vector of integers in FCHK. stdl_fchk_parser_get_vector_numbers Parse a vector of real numbers in FCHK. stdl_fchk_parser_get_vector_numbers_immediate Parse a vector of real numbers in FCHK. stdl_fchk_parser_get_vector_string Parse a vector of strings in FCHK and merge everything in one (long) string. stdl_fchk_parser_skip_intro Skip the beginning of FCHK. stdl_fchk_parser_skip_section Skip the current section."},{"location":"API/utilities/fchk_parser/#function-details","title":"Function Details","text":""},{"location":"API/utilities/fchk_parser/#stdl_basis_data_count_nao","title":"stdl_basis_data_count_nao","text":"<p>int stdl_basis_data_count_nao(stdl_basis_data* dt, size_t* total)</p> <p>Count the number of AO expected for a given basis</p> Parameter <code>dt</code> a valid pointer to data Parameter <code>total</code> the number of AO Return error code"},{"location":"API/utilities/fchk_parser/#stdl_basis_data_delete","title":"stdl_basis_data_delete","text":"<p>int stdl_basis_data_delete(stdl_basis_data* dt)</p> <p>Delete a basis set data holder.</p> Parameter <code>dt</code> a valid pointer to data Return error code"},{"location":"API/utilities/fchk_parser/#stdl_basis_data_new","title":"stdl_basis_data_new","text":"<p>int stdl_basis_data_new(size_t nbas, size_t nprim, stdl_basis_data **dt_ptr)</p> <p>Create a new basis set data holder.</p> Parameter <code>nbas</code> Number of basis function, must be &gt;0 Parameter <code>nprim</code> Number of primitives, must be <code>nprim &gt;= nbas</code> Parameter <code>dt_ptr</code> data to be created Return error code"},{"location":"API/utilities/fchk_parser/#stdl_basis_data_to_basis","title":"stdl_basis_data_to_basis","text":"<p>int stdl_basis_data_to_basis(stdl_basis_data *dt, size_t natm, double *atm, stdl_basis **bs_ptr)</p> <p>Convert a basis set data to an actual <code>stdl_basis</code>.</p> Parameter <code>dt</code> a valid pointer to data Parameter <code>natm</code> number of atoms, must be &gt; 0. Parameter <code>atm</code> <code>double[4*natm]</code> list of atoms with nuclear charge (0) and coordinates (1:3) Parameter <code>bs_ptr</code> Resulting basis set. Return error code"},{"location":"API/utilities/fchk_parser/#stdl_fchk_parser_extract","title":"stdl_fchk_parser_extract","text":"<p>int stdl_fchk_parser_extract(stdl_lexer *lx, stdl_wavefunction **wf_ptr, stdl_basis **bs_ptr)</p> <p>Extract a wavefunction (<code>stdl_wavefunction</code>) and a basis set (<code>stdl_basis</code>) from a FCHK file. Expects that the introduction has been skipped (with <code>stdl_fchk_parser_skip_intro()</code>). Expects that the section comes in the order in which Gaussian prints them. The FCHK is read up to the \"Alpha MO coefficients\" section. Then, it:</p> <ul> <li>build the wavefunction and basis set,</li> <li>reorder the LCAO coefficients to match the order of <code>libcint</code>,</li> <li>computes the overlap matrix (<code>S</code>) as this is not available in the FCHK.</li> </ul> Parameter <code>lx</code> a valid lexer, opened on a FCHK Parameter <code>wf_ptr</code> a wavefunction to be created Parameter <code>bs_ptr</code> a basis set to be created Return if everything went well, <code>STDL_ERR_OK</code>."},{"location":"API/utilities/fchk_parser/#stdl_fchk_parser_get_scalar_integer","title":"stdl_fchk_parser_get_scalar_integer","text":"<p>int stdl_fchk_parser_get_scalar_integer(stdl_lexer* lx, long *value)</p> <p>Parse a scalar integer.</p> Parameter <code>lx</code> a valid lexer Parameter <code>value</code> the value, if any. Return <code>STDL_ERR_OK</code> if everything was ok, error code otherwise"},{"location":"API/utilities/fchk_parser/#stdl_fchk_parser_get_scalar_number","title":"stdl_fchk_parser_get_scalar_number","text":"<p>int stdl_fchk_parser_get_scalar_number(stdl_lexer* lx, double* value)</p> <p>Parse a scalar real number.</p> Parameter <code>lx</code> a valid lexer Parameter <code>value</code> the value, if any. Return <code>STDL_ERR_OK</code> if everything was ok, error code otherwise"},{"location":"API/utilities/fchk_parser/#stdl_fchk_parser_get_section_info","title":"stdl_fchk_parser_get_section_info","text":"<p>int stdl_fchk_parser_get_section_info(stdl_lexer* lx, char** name, char* type, int* is_scalar)</p> <p>Parse the info of a section in FCHK. Stops at the beginning of the value (if scalar) or of the size (if vector).</p> Parameter <code>lx</code> a valid lexer Parameter <code>name</code> the name of the section Parameter <code>type</code> the type of section. Valid outputs are <code>I</code>, <code>R</code>, and <code>C</code>. Parameter <code>is_scalar</code> <code>1</code> if the section is a scalar Return <code>STDL_ERR_OK</code> if everything was ok, error code otherwise"},{"location":"API/utilities/fchk_parser/#stdl_fchk_parser_get_vector_integers","title":"stdl_fchk_parser_get_vector_integers","text":"<p>int stdl_fchk_parser_get_vector_integers(stdl_lexer* lx, size_t* sz, long **vector)</p> <p>Parse a vector of integers in FCHK. Expect the lexer to have stopped right before the size of the vector. Read lines in format <code>6I12</code>.</p> Parameter <code>lx</code> a valid lexer Parameter <code>sz</code> size of the vector Parameter <code>vector</code> the vector, if any. Caller is responsible for free'ing it. Return <code>STDL_ERR_OK</code> if everything was ok, error code otherwise"},{"location":"API/utilities/fchk_parser/#stdl_fchk_parser_get_vector_integers_immediate","title":"stdl_fchk_parser_get_vector_integers_immediate","text":"<p>int stdl_fchk_parser_get_vector_integers_immediate(stdl_lexer* lx, size_t sz, long **vector)</p> <p>Parse a vector of integers in FCHK. Expect the lexer to have stopped right before the size of the vector. Read lines in format <code>6I12</code>.</p> <p>Note</p> <p>Immediate version: <code>*vector</code> must be have been allocated. This version is to be used when one knows in advance the shape of the data (because, e.g., it was given by another section) and tries to avoid copy.</p> Parameter <code>lx</code> a valid lexer Parameter <code>sz</code> expected size of the vector, will be checked. Parameter <code>vector</code> the vector, which will be filled. Return <code>STDL_ERR_OK</code> if everything was ok, error code otherwise"},{"location":"API/utilities/fchk_parser/#stdl_fchk_parser_get_vector_numbers","title":"stdl_fchk_parser_get_vector_numbers","text":"<p>int stdl_fchk_parser_get_vector_numbers(stdl_lexer* lx, size_t* sz, double** vector)</p> <p>Parse a vector of real numbers in FCHK. Expect the lexer to have stopped right before the size of the vector. Read lines in format <code>5E16.8</code>.</p> Parameter <code>lx</code> a valid lexer Parameter <code>sz</code> size of the vector Parameter <code>vector</code> the vector, if any. Caller is responsible for free'ing it. Return <code>STDL_ERR_OK</code> if everything was ok, error code otherwise"},{"location":"API/utilities/fchk_parser/#stdl_fchk_parser_get_vector_numbers_immediate","title":"stdl_fchk_parser_get_vector_numbers_immediate","text":"<p>int stdl_fchk_parser_get_vector_numbers_immediate(stdl_lexer* lx, size_t sz, double** vector)</p> <p>Parse a vector of real numbers in FCHK. Expect the lexer to have stopped right before the size of the vector. Read lines in format <code>5E16.8</code>.</p> <p>Note</p> <p>Immediate version: <code>*vector</code> must be have been allocated. This version is to be used when one knows in advance the shape of the data (because, e.g., it was given by another section) and tries to avoid copy.</p> Parameter <code>lx</code> a valid lexer Parameter <code>sz</code> expected size of the vector, will be checked. Parameter <code>vector</code> the vector, which will be filled. Return <code>STDL_ERR_OK</code> if everything was ok, error code otherwise"},{"location":"API/utilities/fchk_parser/#stdl_fchk_parser_get_vector_string","title":"stdl_fchk_parser_get_vector_string","text":"<p>int stdl_fchk_parser_get_vector_string(stdl_lexer* lx, size_t* sz, char **out)</p> <p>Parse a vector of strings in FCHK and merge everything in one (long) string. Expect the lexer to have stopped right before the size of the vector. Read lines in format <code>5A12</code>.</p> Parameter <code>lx</code> a valid lexer Parameter <code>sz</code> size of the vector Parameter <code>out</code> the string, if any. Caller is responsible for free'ing it. Return <code>STDL_ERR_OK</code> if everything was ok, error code otherwise"},{"location":"API/utilities/fchk_parser/#stdl_fchk_parser_skip_intro","title":"stdl_fchk_parser_skip_intro","text":"<p>int stdl_fchk_parser_skip_intro(stdl_lexer* lx)</p> <p>Skip the beginning of FCHK. Skip i.e., the two first lines (beginning of title section + type, method, basis), since this is info one can found in other places of the file anyway.</p> Parameter <code>lx</code> a valid lexer Return <code>STDL_ERR_OK</code> if everything was ok, error code otherwise"},{"location":"API/utilities/fchk_parser/#stdl_fchk_parser_skip_section","title":"stdl_fchk_parser_skip_section","text":"<p>int stdl_fchk_parser_skip_section(stdl_lexer* lx, char type, int is_scalar)</p> <p>Skip the current section. In practice, skip as much <code>NL</code> as required.</p> Parameter <code>lx</code> a valid lexer Parameter <code>type</code> type of the value(s) Parameter <code>is_scalar</code> <code>1</code> if scalar, 0 if vector Return <code>STDL_ERR_OK</code> if everything was ok, error code otherwise"},{"location":"API/utilities/fchk_parser/stdl_basis_data_/","title":"stdl_basis_data_","text":"<p>struct stdl_basis_data_</p> <p>Transpose the LCAO coefficients from Gaussian 16 so that they match <code>libcint</code>, cartesian functions.</p> <p>Transpose the LCAO coefficients from Gaussian 16 so that they match <code>libcint</code>, spherical functions.</p> <p>Structure that holds basis set data in a format that resemble the one used by Gaussian in its FCHK.</p>"},{"location":"API/utilities/fchk_parser/stdl_basis_data_/#variables","title":"Variables","text":"Name Description nbas number of basis functions nprim number of primitives, <code>nprim &gt;= nbas</code> bas_types <code>long[nbas]</code>, the angular moment of each basis function. prims_per_bas <code>long[nbas]</code> the number of primitive in each basis function bastoatm <code>long[nbas]</code>, 1-based list of correspondence between basis function and atom benv <code>double[3 * nprim]</code>, list of exponents, coefs, ans S=P coefs, as <code>[e0, e1, ..., eN, c0, c1, ..., cN, cp0, cp1, ..., cpN]</code>."},{"location":"API/utilities/fchk_parser/stdl_basis_data_/#variable-details","title":"Variable Details","text":""},{"location":"API/utilities/fchk_parser/stdl_basis_data_/#bas_types","title":"bas_types","text":"<p>long *bas_types</p> <p><code>long[nbas]</code>, the angular moment of each basis function.  Use the Gaussian specification, so <code>0=s, 1=p, -1=sp, 2=6d, -2=5d, 3=10f, -3=7f</code> (and so all).</p>"},{"location":"API/utilities/fchk_parser/stdl_basis_data_/#bastoatm","title":"bastoatm","text":"<p>long *bastoatm</p> <p><code>long[nbas]</code>, 1-based list of correspondence between basis function and atom</p>"},{"location":"API/utilities/fchk_parser/stdl_basis_data_/#benv","title":"benv","text":"<p>double *benv</p> <p><code>double[3 * nprim]</code>, list of exponents, coefs, ans S=P coefs, as <code>[e0, e1, ..., eN, c0, c1, ..., cN, cp0, cp1, ..., cpN]</code>.</p>"},{"location":"API/utilities/fchk_parser/stdl_basis_data_/#nbas","title":"nbas","text":"<p>size_t nbas</p> <p>number of basis functions</p>"},{"location":"API/utilities/fchk_parser/stdl_basis_data_/#nprim","title":"nprim","text":"<p>size_t nprim</p> <p>number of primitives, <code>nprim &gt;= nbas</code></p>"},{"location":"API/utilities/fchk_parser/stdl_basis_data_/#prims_per_bas","title":"prims_per_bas","text":"<p>long *prims_per_bas</p> <p><code>long[nbas]</code> the number of primitive in each basis function</p>"},{"location":"API/utilities/lexer/","title":"Lexer","text":"<p>A character per character lexer, that assign types to certain kind of characters.</p> <pre><code>#include &lt;stdlite/utils/lexer.h&gt;\n</code></pre>"},{"location":"API/utilities/lexer/#types","title":"Types","text":"Name Description stdl_lexer_ A structure that represent a lexer. stdl_token_type_ Enum for the different token types."},{"location":"API/utilities/lexer/#macros","title":"Macros","text":"Name Description STDL_LEXER_STREAM_BUFF_SIZE Buffer size for the lexer."},{"location":"API/utilities/lexer/#functions","title":"Functions","text":"Name Description stdl_lexer_advance Advance to the next token, except if there are no more token to extract (current token is EOF). stdl_lexer_delete Free the lexer. stdl_lexer_eat If the current token type is of <code>type</code>, advance to the next token. stdl_lexer_new Create a new lexer object (<code>stdl_lexer*</code>), provided that <code>input</code> is a valid <code>FILE*</code>. stdl_lexer_skip Skip tokens while <code>predicate</code> is true (and one does not hit <code>EOF</code>). stdl_lexer_skip_whitespace_and_nl Skip all tokens that are <code>STDL_TK_WHITESPACE</code> or <code>STDL_TK_NL</code>."},{"location":"API/utilities/lexer/#macro-details","title":"Macro Details","text":""},{"location":"API/utilities/lexer/#stdl_lexer_stream_buff_size","title":"STDL_LEXER_STREAM_BUFF_SIZE","text":"<p>#define STDL_LEXER_STREAM_BUFF_SIZE</p> <p>Buffer size for the lexer.</p>"},{"location":"API/utilities/lexer/#function-details","title":"Function Details","text":""},{"location":"API/utilities/lexer/#stdl_lexer_advance","title":"stdl_lexer_advance","text":"<p>int stdl_lexer_advance(stdl_lexer *lx, int shift)</p> <p>Advance to the next token, except if there are no more token to extract (current token is EOF).</p> Parameter <code>lx</code> a valid lexer Parameter <code>shift</code> How much to advance. Valid choices are 0 or 1. Return <code>STDL_ERR_OK</code> if current token is not <code>STDL_TK_EOF</code>, <code>STDL_ERR_UTIL_LEXER</code> otherwise."},{"location":"API/utilities/lexer/#stdl_lexer_delete","title":"stdl_lexer_delete","text":"<p>int stdl_lexer_delete(stdl_lexer *lx)</p> <p>Free the lexer.</p> Parameter <code>lx</code> a valid lexer Return <code>STDL_ERR_OK</code>"},{"location":"API/utilities/lexer/#stdl_lexer_eat","title":"stdl_lexer_eat","text":"<p>int stdl_lexer_eat(stdl_lexer *lx, stdl_token_type t)</p> <p>If the current token type is of <code>type</code>, advance to the next token. Otherwise, return an error.</p> Parameter <code>lx</code> A valid lexer. Parameter <code>t</code> Type of the token Return <code>STDL_ERR_OK</code> if the current token was of the correct type, <code>STDL_ERR_UTIL_LEXER</code> otherwise."},{"location":"API/utilities/lexer/#stdl_lexer_new","title":"stdl_lexer_new","text":"<p>int stdl_lexer_new(FILE *input, stdl_lexer **lx_ptr)</p> <p>Create a new lexer object (<code>stdl_lexer*</code>), provided that <code>input</code> is a valid <code>FILE*</code>. This object has to be free'd after use.</p> Parameter <code>input</code> A valid <code>FILE*</code>. Parameter <code>lx_ptr</code> lexer object to be created. Return <code>STDL_ERR_OK</code> if everything went well"},{"location":"API/utilities/lexer/#stdl_lexer_skip","title":"stdl_lexer_skip","text":"<p>int stdl_lexer_skip(stdl_lexer *lx, int (*predicate)(int))</p> <p>Skip tokens while <code>predicate</code> is true (and one does not hit <code>EOF</code>).</p> Parameter <code>lx</code> A valid lexer. Parameter <code>predicate</code> predicate of the form <code>int predicate(int c)</code>, where <code>c</code> is the current token value Return <code>STDL_ERR_OK</code>."},{"location":"API/utilities/lexer/#stdl_lexer_skip_whitespace_and_nl","title":"stdl_lexer_skip_whitespace_and_nl","text":"<p>int stdl_lexer_skip_whitespace_and_nl(stdl_lexer *lx)</p> <p>Skip all tokens that are <code>STDL_TK_WHITESPACE</code> or <code>STDL_TK_NL</code>.</p> Parameter <code>lx</code> A valid lexer. Return <code>STDL_ERR_OK</code>."},{"location":"API/utilities/lexer/stdl_lexer_/","title":"stdl_lexer_","text":"<p>struct stdl_lexer_</p> <p>A structure that represent a lexer. This object contains a buffer, <code>stream</code>, that is automatically filled by <code>stdl_lexer_advance</code> when it gets close to the end.</p>"},{"location":"API/utilities/lexer/stdl_lexer_/#variables","title":"Variables","text":"Name Description pos_in_stream Current (0-based) position of the token in the temporary buffer. current_line current (1-based) line in the file. current_pos_in_line current (1-based) position of the token in the line. current_tk_value Current token value, equals to <code>lx-&gt;stream[lx-&gt;pos_in_stream]</code>. current_tk_type Current token type. file The file from which character are read. stream Temporary buffer."},{"location":"API/utilities/lexer/stdl_lexer_/#variable-details","title":"Variable Details","text":""},{"location":"API/utilities/lexer/stdl_lexer_/#current_line","title":"current_line","text":"<p>int current_line</p> <p>current (1-based) line in the file. </p>"},{"location":"API/utilities/lexer/stdl_lexer_/#current_pos_in_line","title":"current_pos_in_line","text":"<p>int current_pos_in_line</p> <p>current (1-based) position of the token in the line. </p>"},{"location":"API/utilities/lexer/stdl_lexer_/#current_tk_type","title":"current_tk_type","text":"<p>stdl_token_type current_tk_type</p> <p>Current token type. </p>"},{"location":"API/utilities/lexer/stdl_lexer_/#current_tk_value","title":"current_tk_value","text":"<p>char current_tk_value</p> <p>Current token value, equals to <code>lx-&gt;stream[lx-&gt;pos_in_stream]</code>. </p>"},{"location":"API/utilities/lexer/stdl_lexer_/#file","title":"file","text":"<p>FILE* file</p> <p>The file from which character are read. </p>"},{"location":"API/utilities/lexer/stdl_lexer_/#pos_in_stream","title":"pos_in_stream","text":"<p>int pos_in_stream</p> <p>Current (0-based) position of the token in the temporary buffer. </p>"},{"location":"API/utilities/lexer/stdl_lexer_/#stream","title":"stream","text":"<p>char* stream</p> <p>Temporary buffer. </p>"},{"location":"API/utilities/lexer/stdl_token_type_/","title":"stdl_token_type_","text":"<p>enum stdl_token_type_</p> <p>Enum for the different token types. To be used in the context of parsing files.</p> STDL_TK_WHITESPACE Space (<code>0x20</code>), horizontal tab (<code>0x9</code>) STDL_TK_NL Linefeed (<code>\\n</code>, <code>U+000A</code>) STDL_TK_CR Carriage return (<code>\\r</code>, <code>U+000D</code>) STDL_TK_DIGIT Digit, <code>[0-9]</code> STDL_TK_ALPHA Alpha character, <code>[a-zA-Z]</code> STDL_TK_COMMA Comma, <code>,</code> STDL_TK_DOT Dot, <code>.</code> STDL_TK_ESCAPE Escape character, <code>\\</code> STDL_TK_QUOTE Quote, <code>\"</code> STDL_TK_DASH Dash, <code>-</code> STDL_TK_PLUS Plus, <code>+</code> STDL_TK_EQ Equal, <code>=</code> STDL_TK_EOF End of file, <code>0x0</code> STDL_TK_CHAR Anything else."},{"location":"API/utilities/matrix/","title":"Matrices","text":"<p>Utilities to work with matrices.</p> <p>Note</p> <ul> <li>For symmetric matrices (<code>sy</code>), it is generally assumed that the lower triangle part (<code>UPLO=L</code>) is provided, while the upper part might not be referenced.</li> <li>Symmetry packed storage (<code>sp</code>) refers to the lower triangle form (<code>UPLO=L</code>), so: <code>[a_00, a_10, a_11, a_20, a_21, ..., a_NN]</code>.</li> </ul> <pre><code>#include &lt;stdlite/utils/matrix.h&gt;\n</code></pre>"},{"location":"API/utilities/matrix/#macros","title":"Macros","text":"Name Description STDL_MATRIX_MAX_COLS Maximum number of columns per batch"},{"location":"API/utilities/matrix/#functions","title":"Functions","text":"Name Description STDL_MATRIX_SP_IDX Get the index corresponding to an element of a symmetric packed (SP) matrix. STDL_MATRIX_SP_SIZE Get the size of a symmetric packed (SP) matrix of size <code>n</code>. stdl_matrix_dge_print Print a double precision matrix. stdl_matrix_dsp_blowge Blow a (double-precision) symmetry packed matrix (<code>in</code>) into a full storage (<code>ge</code>) matrix (<code>out</code>). stdl_matrix_dsp_blowsy Blow a (double-precision) symmetry packed matrix (<code>in</code>) into a full storage (symmetric, <code>sy</code>) matrix (<code>out</code>). stdl_matrix_dsp_print Print a symmetric (thus square) packed matrix. stdl_matrix_dsp_sqrt Compute the square root of a <code>sp</code> matrix (in double precision), <code>*mat</code>, in place. stdl_matrix_dsp_sqrt_sy Compute the square root of a <code>sp</code> matrix (in double precision), and output in <code>sy</code> format. stdl_matrix_dsy_shrinksp Shrink a (double-precision) full storage (symmetric, <code>sy</code>) matrix (<code>in</code>) into a symmetry packed matrix (<code>out</code>). stdl_matrix_sge_print Print a single precision matrix. stdl_matrix_sge_transpose Transpose a (single precision) rectangular matrix in place. stdl_matrix_ssp_blowge Blow a (single-precision) symmetry packed matrix (<code>in</code>) into a full storage (<code>ge</code>) matrix (<code>out</code>). stdl_matrix_ssp_blowsy Blow a (single-precision) symmetry packed matrix (<code>in</code>) into a full storage (symmetric, <code>sy</code>) matrix (<code>out</code>). stdl_matrix_ssp_print Print a symmetric (thus square) packed matrix. stdl_matrix_ssp_sqrt Compute the square root of a <code>sp</code> matrix (in single precision), <code>*mat</code>, in place. stdl_matrix_ssp_sqrt_sy Compute the square root of a <code>sp</code> matrix (in single precision), and output in <code>sy</code> format. stdl_matrix_ssy_shrinksp Shrink a (single-precision) full storage (symmetric, <code>sy</code>) matrix (<code>in</code>) into a symmetry packed matrix (<code>out</code>)."},{"location":"API/utilities/matrix/#macro-details","title":"Macro Details","text":""},{"location":"API/utilities/matrix/#stdl_matrix_max_cols","title":"STDL_MATRIX_MAX_COLS","text":"<p>#define STDL_MATRIX_MAX_COLS</p> <p>Maximum number of columns per batch</p>"},{"location":"API/utilities/matrix/#function-details","title":"Function Details","text":""},{"location":"API/utilities/matrix/#stdl_matrix_sp_idx","title":"STDL_MATRIX_SP_IDX","text":"<p>static inline size_t STDL_MATRIX_SP_IDX(size_t i, size_t j)</p> <p>Get the index corresponding to an element of a symmetric packed (SP) matrix. <code>i</code> is the row, while <code>j</code> is the column.</p>"},{"location":"API/utilities/matrix/#stdl_matrix_sp_size","title":"STDL_MATRIX_SP_SIZE","text":"<p>static inline size_t STDL_MATRIX_SP_SIZE(size_t nx)</p> <p>Get the size of a symmetric packed (SP) matrix of size <code>n</code>.</p>"},{"location":"API/utilities/matrix/#stdl_matrix_dge_print","title":"stdl_matrix_dge_print","text":"<p>int stdl_matrix_dge_print(size_t rows, size_t columns, double *matrix, char *title)</p> <p>Print a double precision matrix.</p> Parameter <code>rows</code> number of rows, must be &gt;0. Parameter <code>columns</code> number of columns. If 0, assume that the matrix is symmetric. Parameter <code>matrix</code> <code>double[rows*columns]</code> the matrix Parameter <code>title</code> title to be printed if not <code>NULL</code>. Return <code>STDL_ERR_OK</code>"},{"location":"API/utilities/matrix/#stdl_matrix_dsp_blowge","title":"stdl_matrix_dsp_blowge","text":"<p>int stdl_matrix_dsp_blowge(int issym, size_t n, double *in, double *out)</p> <p>Blow a (double-precision) symmetry packed matrix (<code>in</code>) into a full storage (<code>ge</code>) matrix (<code>out</code>).</p> Parameter <code>issym</code> whether the input is symmetric (<code>issym != 0 =&gt; out[i,j] = out[j,i]</code>) or antisymmetric (<code>issym == 0 =&gt; out[i,j] = -out[j,i]</code>) Parameter <code>n</code> order of <code>in</code> and <code>out</code> Parameter <code>in</code> <code>double[STDL_SP_SIZE(n)]</code> a matrix in symmetry packed storage Parameter <code>out</code> <code>double[n,n]</code> the resulting matrix. Return error code"},{"location":"API/utilities/matrix/#stdl_matrix_dsp_blowsy","title":"stdl_matrix_dsp_blowsy","text":"<p>int stdl_matrix_dsp_blowsy(size_t n, char uplo, double *in, double *out)</p> <p>Blow a (double-precision) symmetry packed matrix (<code>in</code>) into a full storage (symmetric, <code>sy</code>) matrix (<code>out</code>).</p> Parameter <code>n</code> order of <code>in</code> and <code>out</code> Parameter <code>uplo</code> whether <code>in</code> and <code>out</code> are upper (<code>U</code>) or lower (<code>L</code>) triangular. Parameter <code>in</code> <code>double[STDL_SP_SIZE(n)]</code> a matrix in symmetry packed storage Parameter <code>out</code> <code>double[n,n]</code> the resulting matrix. Return error code"},{"location":"API/utilities/matrix/#stdl_matrix_dsp_print","title":"stdl_matrix_dsp_print","text":"<p>int stdl_matrix_dsp_print(size_t n, double *matrix, char *title)</p> <p>Print a symmetric (thus square) packed matrix.</p> Parameter <code>n</code> side length of the matrix Parameter <code>double[STDL_MATRIX_SP_SIZE(n)]</code> matrix the matrix Parameter <code>title</code> title to be printed if not <code>NULL</code>. Return <code>STDL_ERR_OK</code>"},{"location":"API/utilities/matrix/#stdl_matrix_dsp_sqrt","title":"stdl_matrix_dsp_sqrt","text":"<p>int stdl_matrix_dsp_sqrt(size_t n, double *mat)</p> <p>Compute the square root of a <code>sp</code> matrix (in double precision), <code>*mat</code>, in place.</p> \\[X^{1/2} = U\\,\\varepsilon^{1/2}\\,U^T,\\] <p>where \\(\\varepsilon\\) are its eigenvalues, and \\(U\\) are its eigenvectors.</p> Parameter <code>mat</code> <code>double[STDL_MATRIX_SP_SIZE(n)]</code> Unitary matrix to be modified. Parameter <code>n</code> side length of the matrix Return error code"},{"location":"API/utilities/matrix/#stdl_matrix_dsp_sqrt_sy","title":"stdl_matrix_dsp_sqrt_sy","text":"<p>int stdl_matrix_dsp_sqrt_sy(size_t n, double *mat, double* matsy)</p> <p>Compute the square root of a <code>sp</code> matrix (in double precision), and output in <code>sy</code> format.</p> \\[X^{1/2} = U\\,\\varepsilon^{1/2}\\,U^T,\\] <p>where \\(\\varepsilon\\) are the eigenvalues, and \\(U\\) are the eigenvectors.</p> Parameter <code>mat</code> <code>double[STDL_MATRIX_SP_SIZE(n)]</code> a matrix Parameter <code>n</code> side length of the matrix Parameter <code>matsy</code> <code>double[n,n]</code> the square root of <code>mat</code> Return error code"},{"location":"API/utilities/matrix/#stdl_matrix_dsy_shrinksp","title":"stdl_matrix_dsy_shrinksp","text":"<p>int stdl_matrix_dsy_shrinksp(size_t n, char uplo, double *in, double *out)</p> <p>Shrink a (double-precision) full storage (symmetric, <code>sy</code>) matrix (<code>in</code>) into a symmetry packed matrix (<code>out</code>).</p> Parameter <code>n</code> order of <code>in</code> and <code>out</code> Parameter <code>uplo</code> whether <code>in</code> and <code>out</code> are upper (<code>U</code>) or lower (<code>L</code>) triangular. Parameter <code>in</code> <code>double[n,n]</code> a matrix in full symmetric (<code>sp</code>) storage Parameter <code>out</code> <code>double[STDL_SP_SIZE(n)]</code> the resulting matrix. Return error code"},{"location":"API/utilities/matrix/#stdl_matrix_sge_print","title":"stdl_matrix_sge_print","text":"<p>int stdl_matrix_sge_print(size_t rows, size_t columns, float *matrix, char *title)</p> <p>Print a single precision matrix.</p> Parameter <code>rows</code> number of rows, must be &gt;0. Parameter <code>columns</code> number of columns. If 0, assume that the matrix is symmetric. Parameter <code>matrix</code> <code>float[rows*columns]</code>  the matrix Parameter <code>title</code> title to be printed if not <code>NULL</code>. Return <code>STDL_ERR_OK</code>"},{"location":"API/utilities/matrix/#stdl_matrix_sge_transpose","title":"stdl_matrix_sge_transpose","text":"<p>int stdl_matrix_sge_transpose(size_t nrows, size_t ncols, float* mat)</p> <p>Transpose a (single precision) rectangular matrix in place. From https://rosettacode.org/wiki/Matrix_transposition#C and https://en.wikipedia.org/wiki/In-place_matrix_transposition.</p> Parameter <code>nrows</code> number of rows Parameter <code>ncols</code> number of columns Parameter <code>mat</code> <code>float[nrows * ncols]</code>, matrix to be transposed Return error code"},{"location":"API/utilities/matrix/#stdl_matrix_ssp_blowge","title":"stdl_matrix_ssp_blowge","text":"<p>int stdl_matrix_ssp_blowge(int issym, size_t n, float *in, float *out)</p> <p>Blow a (single-precision) symmetry packed matrix (<code>in</code>) into a full storage (<code>ge</code>) matrix (<code>out</code>).</p> Parameter <code>issym</code> whether the input is symmetric (<code>issym != 0 =&gt; in[i,j] = in[j,i]</code>) or antisymmetric (<code>issym == 0 =&gt; in[i,j] = -in[j,i]</code>) Parameter <code>n</code> order of <code>in</code> and <code>out</code> Parameter <code>in</code> <code>float[STDL_SP_SIZE(n)]</code> a matrix in symmetry packed storage Parameter <code>out</code> <code>float[n,n]</code> the resulting matrix. Return error code"},{"location":"API/utilities/matrix/#stdl_matrix_ssp_blowsy","title":"stdl_matrix_ssp_blowsy","text":"<p>int stdl_matrix_ssp_blowsy(size_t n, char uplo, float *in, float *out)</p> <p>Blow a (single-precision) symmetry packed matrix (<code>in</code>) into a full storage (symmetric, <code>sy</code>) matrix (<code>out</code>).</p> Parameter <code>n</code> order of <code>in</code> and <code>out</code> Parameter <code>uplo</code> whether <code>in</code> and <code>out</code> are upper (<code>U</code>) or lower (<code>L</code>) triangular. Parameter <code>in</code> <code>float[STDL_SP_SIZE(n)]</code> a matrix in symmetry packed storage Parameter <code>out</code> <code>float[n,n]</code> the resulting matrix. Return error code"},{"location":"API/utilities/matrix/#stdl_matrix_ssp_print","title":"stdl_matrix_ssp_print","text":"<p>int stdl_matrix_ssp_print(size_t n, float *matrix, char *title)</p> <p>Print a symmetric (thus square) packed matrix.</p> Parameter <code>n</code> side length of the matrix Parameter <code>float[STDL_MATRIX_SP_SIZE(n)]</code> matrix the matrix Parameter <code>title</code> title to be printed if not <code>NULL</code>. Return <code>STDL_ERR_OK</code>"},{"location":"API/utilities/matrix/#stdl_matrix_ssp_sqrt","title":"stdl_matrix_ssp_sqrt","text":"<p>int stdl_matrix_ssp_sqrt(size_t n, float *mat)</p> <p>Compute the square root of a <code>sp</code> matrix (in single precision), <code>*mat</code>, in place.</p> \\[X^{1/2} = U\\,\\varepsilon^{1/2}\\,U^T,\\] <p>where \\(\\varepsilon\\) are its eigenvalues, and \\(U\\) are its eigenvectors.</p> Parameter <code>mat</code> <code>float[STDL_MATRIX_SP_SIZE(n)]</code> Unitary matrix to be modified. Parameter <code>n</code> side length of the matrix Return error code"},{"location":"API/utilities/matrix/#stdl_matrix_ssp_sqrt_sy","title":"stdl_matrix_ssp_sqrt_sy","text":"<p>int stdl_matrix_ssp_sqrt_sy(size_t n, float *mat, float * matsy)</p> <p>Compute the square root of a <code>sp</code> matrix (in single precision), and output in <code>sy</code> format.</p> \\[X^{1/2} = U\\,\\varepsilon^{1/2}\\,U^T,\\] <p>where \\(\\varepsilon\\) are the eigenvalues, and \\(U\\) are the eigenvectors.</p> Parameter <code>mat</code> <code>floay[STDL_MATRIX_SP_SIZE(n)]</code> a matrix Parameter <code>n</code> side length of the matrix Parameter <code>matsy</code> <code>float[n,n]</code> the square root of <code>mat</code> Return error code"},{"location":"API/utilities/matrix/#stdl_matrix_ssy_shrinksp","title":"stdl_matrix_ssy_shrinksp","text":"<p>int stdl_matrix_ssy_shrinksp(size_t n, char uplo, float *in, float *out)</p> <p>Shrink a (single-precision) full storage (symmetric, <code>sy</code>) matrix (<code>in</code>) into a symmetry packed matrix (<code>out</code>).</p> Parameter <code>n</code> order of <code>in</code> and <code>out</code> Parameter <code>uplo</code> whether <code>in</code> and <code>out</code> are upper (<code>U</code>) or lower (<code>L</code>) triangular. Parameter <code>in</code> <code>float[n,n]</code> a matrix in full symmetric (<code>sp</code>) storage Parameter <code>out</code> <code>float[STDL_SP_SIZE(n)]</code> the resulting matrix. Return error code"},{"location":"API/utilities/molden_parser/","title":"MOLDEN file parser","text":"<p>Parser for MOLDEN file, a common container of QM results that can be generated by (or, sometimes, from) a bunch of quantum chemistry programs. The MOLDEN file format originates from the MOLDEN program whose goal was to visualize molecular orbitals.</p> <pre><code>#include &lt;stdlite/utils/molden_parser.h&gt;\n</code></pre> <p>By default, cartesian orbitals are assumed, unless <code>[5D]</code> or <code>[5D7F]</code> is found. The ordering of the orbitals for a given angular momentum follows the one of Gaussian (see there).</p> <p>Warning</p> <p>Mixing of cartesian and spherical functions is not supported. Thus, <code>[5D10F]</code> and <code>[7F]</code> will result in an error.</p>"},{"location":"API/utilities/molden_parser/#functions","title":"Functions","text":"Name Description stdl_molden_parser_extract Extract a wavefunction (<code>stdl_wavefunction</code>) and a basis set (<code>stdl_basis</code>) from a MOLDEN file. stdl_molden_parser_read_atoms_section Read <code>[Atoms]</code> section content. stdl_molden_parser_read_gto_section Read <code>[GTO]</code> section content. stdl_molden_parser_read_mo_section Read <code>[MO]</code> section content. stdl_molden_parser_read_section_title Read section title. stdl_molden_parser_skip_section Skip everything 'til next section."},{"location":"API/utilities/molden_parser/#function-details","title":"Function Details","text":""},{"location":"API/utilities/molden_parser/#stdl_molden_parser_extract","title":"stdl_molden_parser_extract","text":"<p>int stdl_molden_parser_extract(stdl_lexer* lx, stdl_wavefunction** wf_ptr, stdl_basis** bs_ptr)</p> <p>Extract a wavefunction (<code>stdl_wavefunction</code>) and a basis set (<code>stdl_basis</code>) from a MOLDEN file. Expects the file to starts with <code>[Molden Format]</code>.</p> Parameter <code>lx</code> a valid lexer Parameter <code>wf_ptr</code> wavefunction to be created Parameter <code>bs_ptr</code> basis set to be created Return error code"},{"location":"API/utilities/molden_parser/#stdl_molden_parser_read_atoms_section","title":"stdl_molden_parser_read_atoms_section","text":"<p>int stdl_molden_parser_read_atoms_section(stdl_lexer* lx, size_t* natm, double** atm)</p> <p>Read <code>[Atoms]</code> section content. Expects <code>]</code>. Ends on <code>[</code>.</p> Parameter <code>lx</code> a valid lexer Parameter <code>natm</code> number of atoms, should be &gt;0. Parameter <code>atm</code> <code>double[4*natm]</code> list of atoms with nuclear charge (0) and coordinates (1:3) to be created Return error code"},{"location":"API/utilities/molden_parser/#stdl_molden_parser_read_gto_section","title":"stdl_molden_parser_read_gto_section","text":"<p>int stdl_molden_parser_read_gto_section(stdl_lexer *lx, size_t natm, int use_spherical, stdl_basis_data **dt_ptr)</p> <p>Read <code>[GTO]</code> section content. Expects <code>]</code>. Ends on <code>[</code>.</p> Parameter <code>lx</code> a valid lexer Parameter <code>atm</code> number of atoms, must be &gt;0. Parameter <code>use_spherical</code> assume spherical function instead of cartesian Parameter <code>dt_ptr</code> basis data to be created Return error code"},{"location":"API/utilities/molden_parser/#stdl_molden_parser_read_mo_section","title":"stdl_molden_parser_read_mo_section","text":"<p>int stdl_molden_parser_read_mo_section(stdl_lexer *lx, size_t nao, size_t *nmo, size_t *nocc, double **e, double **C)</p> <p>Read <code>[MO]</code> section content. Expects <code>]</code>. Ends on <code>[</code>.</p> Parameter <code>lx</code> a valid lexer Parameter <code>nao</code> number of ao, must be &gt;0. Parameter <code>nmo</code> number of MO Parameter <code>e</code> <code>double[nmo]</code> energies of each MO Parameter <code>C</code> <code>double[nmo, nao]</code> coefficients for each MO Return error code"},{"location":"API/utilities/molden_parser/#stdl_molden_parser_read_section_title","title":"stdl_molden_parser_read_section_title","text":"<p>int stdl_molden_parser_read_section_title(stdl_lexer* lx, char** title)</p> <p>Read section title. Expects <code>[</code> (as the first character of a line!), ends after <code>]</code>.</p> Parameter <code>lx</code> a valid lexer Parameter <code>title</code> title to be read. Return error code"},{"location":"API/utilities/molden_parser/#stdl_molden_parser_skip_section","title":"stdl_molden_parser_skip_section","text":"<p>int stdl_molden_parser_skip_section(stdl_lexer* lx)</p> <p>Skip everything 'til next section. Expects <code>]</code>. Ends on <code>[</code>.</p> Parameter <code>lx</code> a valid lexer Return error code"},{"location":"API/utilities/permutations/","title":"Permutations","text":"<p>Deal with permutations.</p> <pre><code>#include &lt;stdlite/utils/permutations.h&gt;\n</code></pre> <p>Warning</p> <p>When using permutations on an array of structure, keep in mind structure padding, especially when removing duplicates.</p> <p>```</p>"},{"location":"API/utilities/permutations/#types","title":"Types","text":"Name Description stdl_permutation_ A sequence of permutations."},{"location":"API/utilities/permutations/#functions","title":"Functions","text":"Name Description stdl_permutations_delete Delete a sequence of permutations. stdl_permutations_new Build a sequence of <code>fac(nelm)</code> permutations from <code>original_set</code> (with duplicates if elements of <code>original_set</code> are equals). stdl_permutations_remove_duplicates Remove duplicates in a sequence of permutations."},{"location":"API/utilities/permutations/#function-details","title":"Function Details","text":""},{"location":"API/utilities/permutations/#stdl_permutations_delete","title":"stdl_permutations_delete","text":"<p>int stdl_permutations_delete(stdl_permutations* permutations)</p> <p>Delete a sequence of permutations.</p> Parameter <code>permutations</code> a valid sequence of permutations Return error code"},{"location":"API/utilities/permutations/#stdl_permutations_new","title":"stdl_permutations_new","text":"<p>int stdl_permutations_new(void* original_set, size_t nelm, size_t elmsz, stdl_permutations** permutations)</p> <p>Build a sequence of <code>fac(nelm)</code> permutations from <code>original_set</code> (with duplicates if elements of <code>original_set</code> are equals).</p> Parameter <code>original_set</code> <code>uint8_t[nelm*elemz]</code> a set of <code>nelm</code> elements of <code>elmsz</code> bytes each to be permuted. Parameter <code>nelm</code> number of element in the original_set Parameter <code>elmsz</code> size of each element of the original_set in byte (use <code>sizeof()</code>) Parameter <code>permutations</code> the resulting sequence of permutations. Return error code"},{"location":"API/utilities/permutations/#stdl_permutations_remove_duplicates","title":"stdl_permutations_remove_duplicates","text":"<p>int stdl_permutations_remove_duplicates(stdl_permutations* permutations, size_t nelm, size_t elmsz)</p> <p>Remove duplicates in a sequence of permutations. Note that this implementation scales as \\(\\mathcal{O}(N^2)\\) in the worst case, with \\(N\\) the length of the sequence.</p> Parameter <code>permutations</code> a valid sequence of permutations Parameter <code>nelm</code> number of element in the original set Parameter <code>elmsz</code> size of each element of the original set in byte (use <code>sizeof()</code>) Return error code"},{"location":"API/utilities/permutations/stdl_permutation_/","title":"stdl_permutation_","text":"<p>struct stdl_permutation_</p> <p>A sequence of permutations. Implemented as a linked list.</p>"},{"location":"API/utilities/permutations/stdl_permutation_/#types","title":"Types","text":"Name Description stdl_permutation_ The next element in the set, might be <code>NULL</code>."},{"location":"API/utilities/permutations/stdl_permutation_/#variables","title":"Variables","text":"Name Description perm <code>uint8_t[nelements*sz]</code>, one of the possible permutation of the original set."},{"location":"API/utilities/permutations/stdl_permutation_/#variable-details","title":"Variable Details","text":""},{"location":"API/utilities/permutations/stdl_permutation_/#perm","title":"perm","text":"<p>void* perm</p> <p><code>uint8_t[nelements*sz]</code>, one of the possible permutation of the original set.</p>"},{"location":"API/utilities/permutations/stdl_permutation_/stdl_permutation_/","title":"stdl_permutation_","text":"<p>struct stdl_permutation_</p> <p>The next element in the set, might be <code>NULL</code>.</p>"},{"location":"API/utilities/qexp/","title":"Experimental quantities","text":"<p>Utilities to compute experimental quantities (generally from rotational averaging).</p> <pre><code>#include &lt;stdlite/utils/experimental_quantity.h&gt;\n</code></pre>"},{"location":"API/utilities/qexp/#quantities-that-can-be-computed","title":"Quantities that can be computed","text":"<ul> <li> <p>Polarizability related quantities:</p> \\[\\bar{\\alpha}=\\frac{1}{3}\\sum_i^{xyz} \\alpha_{ii} \\text{ and } \\Delta\\alpha= \\left[\\frac{1}{2}\\sum_{ij}^{xyz} 3\\,\\alpha_{ij}^2 - \\alpha_{ii}\\,\\alpha_{jj}\\right]^{1/2},\\] <p>which are the iso- and anisotropic polarizability values, respectively.</p> </li> <li> <p>Hyper-Rayleigh Scattering (HRS) related quantities:</p> \\[\\begin{aligned} \\langle\\beta^2_{ZZZ}\\rangle &amp;= \\frac{1}{105}\\,\\sum_{ijk}^{xyz} 2\\,\\beta_{ijk}^2 + \\beta_{ijj} \\beta_{ikk} + 4\\, (\\beta_{iij} \\beta_{jkk} + \\beta_{iij} \\beta_{kjk} + \\beta_{ijk} \\beta_{jik}),\\\\ \\langle\\beta^2_{ZXX}\\rangle &amp;= \\frac{1}{105}\\, \\sum_{ijk}^{xyz} 6\\,\\beta_{ijk}^2 + 3\\,\\beta_{ijj} \\beta_{ikk} -2\\, (\\beta_{iij} \\beta_{jkk} +\\beta_{iij} \\beta_{kjk}  +\\beta_{ijk} \\beta_{jik}), \\end{aligned}\\] <p>which can then be used to compute \\(\\beta_{HRS}\\) and DR.</p> </li> </ul>"},{"location":"API/utilities/qexp/#functions","title":"Functions","text":"Name Description stdl_qexp_first_hyperpolarizability_hrs Compute the experimental quantities related to HRS electric first hyperpolarizability. stdl_qexp_polarizability Compute the experimental quantities related to electric polarizability: iso- and anisotropy.  Parameter <code>alpha</code> :    <code>float[STDL_MATRIX_SP_SIZE(3)]</code> the polarizability tensor  Parameter <code>iso</code> :    the isotropic polarizability value  Parameter <code>aniso</code> :    the anisotropic polarizability value  Return :    error code"},{"location":"API/utilities/qexp/#function-details","title":"Function Details","text":""},{"location":"API/utilities/qexp/#stdl_qexp_first_hyperpolarizability_hrs","title":"stdl_qexp_first_hyperpolarizability_hrs","text":"<p>int stdl_qexp_first_hyperpolarizability_hrs(float beta[3][3][3], float* beta2_ZZZ, float* beta2_ZXX)</p> <p>Compute the experimental quantities related to HRS electric first hyperpolarizability.</p> Parameter <code>beta</code> <code>float[3,3,3]</code> the first hyperpolarizability Parameter <code>beta2_ZZZ</code> macroscopic HRS invariant Parameter <code>beta2_ZXX</code> macroscopic HRS invariant Return error code"},{"location":"API/utilities/qexp/#stdl_qexp_polarizability","title":"stdl_qexp_polarizability","text":"<p>int stdl_qexp_polarizability(float * alpha, float* iso, float* aniso)</p> <p>Compute the experimental quantities related to electric polarizability: iso- and anisotropy.</p> Parameter <code>alpha</code> <code>float[STDL_MATRIX_SP_SIZE(3)]</code> the polarizability tensor Parameter <code>iso</code> the isotropic polarizability value Parameter <code>aniso</code> the anisotropic polarizability value Return error code"},{"location":"API/wavefunction/","title":"Wavefunction","text":"<p>Store the result of a QC calculation, which is the input for subsequent (s)TD-DFT calculations.</p> <pre><code>#include &lt;stdlite/wavefunction.h&gt;\n</code></pre>"},{"location":"API/wavefunction/#types","title":"Types","text":"Name Description stdl_wavefunction_ Structure that represent a (closed-shell!"},{"location":"API/wavefunction/#functions","title":"Functions","text":"Name Description stdl_wavefunction_compute_density_dsp Compute the density matrix (<code>sy</code> format). stdl_wavefunction_delete Free the wavefunction. stdl_wavefunction_dge_ao_to_dge_mo Convert \\(X\\) expressed from AO to MO basis. stdl_wavefunction_dsp_ao_to_dsp_mo Convert \\(X\\) expressed from AO to MO basis. stdl_wavefunction_dump_h5 Dump a wavefunction in a H5 file_id  Parameter <code>wf</code> :    the wavefunction  Parameter <code>file_id</code> :    a valid H5 file_id identifier  Return :    error code stdl_wavefunction_load_h5 Load a wavefunction from a H5 file_id  Parameter <code>file_id</code> :    a valid H5 file_id identifier  Parameter <code>wf_ptr</code> :    the resulting wavefunction  Return :    error code stdl_wavefunction_new Create a new wavefunction. stdl_wavefunction_orthogonalize_C_dge Symmetrize the LCAO coefficients in place using a L\u00f6wdin orthogonalization."},{"location":"API/wavefunction/#function-details","title":"Function Details","text":""},{"location":"API/wavefunction/#stdl_wavefunction_compute_density_dsp","title":"stdl_wavefunction_compute_density_dsp","text":"<p>int stdl_wavefunction_compute_density_dsp(size_t nocc, size_t nmo, size_t nao, double *C, double *D)</p> <p>Compute the density matrix (<code>sy</code> format).</p> \\[P_{\\mu\\nu} = \\sum_r^{MO} n_r\\,C_{r\\mu}\\,C_{r\\nu},\\] <p>where \\(n_r\\) is the occupation number of MO \\(r\\).</p> Parameter <code>C</code> <code>double[nmo*nao]</code>, the coefficients Parameter <code>nocc</code> number of occupied orbitals, must be &gt;0. Parameter <code>nmo</code> number of MO, must be &gt;0. Parameter <code>nao</code> number of AO, must be &gt;0. Parameter <code>D</code> <code>double[STDL_MATRIX_SP_SIZE(nao)]</code> the density matrix. Return error code."},{"location":"API/wavefunction/#stdl_wavefunction_delete","title":"stdl_wavefunction_delete","text":"<p>int stdl_wavefunction_delete(stdl_wavefunction* wf)</p> <p>Free the wavefunction.</p> Parameter <code>wf</code> The wavefunction object Return <code>SDTL_ERR_OK</code>"},{"location":"API/wavefunction/#stdl_wavefunction_dge_ao_to_dge_mo","title":"stdl_wavefunction_dge_ao_to_dge_mo","text":"<p>int stdl_wavefunction_dge_ao_to_dge_mo(size_t nao, size_t nmo, double *C, double *X_AO, double *X_MO)</p> <p>Convert \\(X\\) expressed from AO to MO basis.</p> Parameter <code>nao</code> number of AO, must be &gt;0. Parameter <code>nmo</code> number of MO, must be <code>0 &lt; nmo &lt;= nao</code>. Parameter <code>C</code> the LCAO coefficients Parameter <code>X_AO</code> <code>double[nao,nao]</code>, the matrix in AO basis Parameter <code>X_MO</code> <code>double[nmo,nmo]</code>, the matrix in MO basis Return error code"},{"location":"API/wavefunction/#stdl_wavefunction_dsp_ao_to_dsp_mo","title":"stdl_wavefunction_dsp_ao_to_dsp_mo","text":"<p>int stdl_wavefunction_dsp_ao_to_dsp_mo(size_t nao, size_t nmo, double* C, double* X_AO, double* X_MO)</p> <p>Convert \\(X\\) expressed from AO to MO basis. Assume a symmetric property (i.e., <code>X_AO[i,j] = X_AO[j,i]</code>).</p> Parameter <code>nao</code> number of AO, must be &gt;0. Parameter <code>nmo</code> number of MO, must be <code>0 &lt; nmo &lt;= nao</code>. Parameter <code>C</code> the LCAO coefficients Parameter <code>X_AO</code> <code>double[STDL_MATRIX_SP_SIZE(nao)]</code>, the matrix in AO basis Parameter <code>X_MO</code> <code>double[STDL_MATRIX_SP_SIZE(nmo)]</code>, the matrix in MO basis Return error code"},{"location":"API/wavefunction/#stdl_wavefunction_dump_h5","title":"stdl_wavefunction_dump_h5","text":"<p>int stdl_wavefunction_dump_h5(stdl_wavefunction* wf, hid_t file_id)</p> <p>Dump a wavefunction in a H5 file_id</p> Parameter <code>wf</code> the wavefunction Parameter <code>file_id</code> a valid H5 file_id identifier Return error code"},{"location":"API/wavefunction/#stdl_wavefunction_load_h5","title":"stdl_wavefunction_load_h5","text":"<p>int stdl_wavefunction_load_h5(hid_t file_id, stdl_wavefunction **wf_ptr)</p> <p>Load a wavefunction from a H5 file_id</p> Parameter <code>file_id</code> a valid H5 file_id identifier Parameter <code>wf_ptr</code> the resulting wavefunction Return error code"},{"location":"API/wavefunction/#stdl_wavefunction_new","title":"stdl_wavefunction_new","text":"<p>int stdl_wavefunction_new(size_t natm, size_t nocc, size_t nao, size_t nmo, stdl_wavefunction **wf_ptr)</p> <p>Create a new wavefunction.</p> Parameter <code>natm</code> number of atom (should be &gt;0) Parameter <code>nocc</code> number of occupied orbitals, must be &gt;0. Parameter <code>nao</code> number of atomic orbitals (should be &gt;0) Parameter <code>nmo</code> number of molecular orbitals (should fulfill <code>nelec &lt;= 2*nmo &lt;= 2*nao</code>) Parameter <code>wf_ptr</code> wavefunction object to be initialized Return <code>SDTL_ERR_OK</code> if everything was ok."},{"location":"API/wavefunction/#stdl_wavefunction_orthogonalize_c_dge","title":"stdl_wavefunction_orthogonalize_C_dge","text":"<p>int stdl_wavefunction_orthogonalize_C_dge(size_t nmo, size_t nao, double *S, double *C)</p> <p>Symmetrize the LCAO coefficients in place using a L\u00f6wdin orthogonalization.</p> <p>In other words:</p> \\[C^{\\perp} = S^{1/2}\\,C.\\] <p>See, e.g., there.</p> Parameter <code>nmo</code> number of MO, must be &gt;0. Parameter <code>nao</code> number of AO, must be &gt;0. Parameter <code>S</code> <code>double[STLD_MATRIX_SP_SIZE(nao)]</code>, the overlap matrix Parameter <code>C</code> <code>double[nmo*nao]</code>, the coefficients to be orthogonalized Return the error code"},{"location":"API/wavefunction/stdl_wavefunction_/","title":"stdl_wavefunction_","text":"<p>struct stdl_wavefunction_</p> <p>Structure that represent a (closed-shell!) wavefunction. So, in practice, it stores the results of a QC calculation for subsequent (s)TD-DFT calculation. Thus, it contains geometrical information, as well as the <code>S</code> (overlap), <code>C</code> (LCAO coefficients), and <code>e</code> (MO energies) matrices. It is assumed that the MO are ordered in increasing energy values, and thus that electrons sits on the lower levels.</p> <p>Note: this structure takes about <code>(3 * natm + nmo + nao * (nao + nmo)) * sizeof(double) + nao * sizeof(size_t)</code> bytes of space when correctly allocated.</p>"},{"location":"API/wavefunction/stdl_wavefunction_/#variables","title":"Variables","text":"Name Description natm Number of atoms atm <code>double[natm*4]</code>, list of atoms with nuclear charge (0) and coordinates (1:3) nocc Number of occupied MO. nao Number of AO. nmo Number of MO. aotoatm <code>size_t[nao]</code>, 0-based list of corresponding atom for each AO. S <code>double[STDL_MATRIX_SP_SIZE(nao)]</code>, the overlap matrix \\(S_{\\mu\\nu}\\). C <code>double[nmo*nao]</code>, the LCAO coefficients matrix \\(C_{pq}\\). e <code>double[nmo]</code>, the MO energy vector \\(\\varepsilon_p\\) for each MO."},{"location":"API/wavefunction/stdl_wavefunction_/#variable-details","title":"Variable Details","text":""},{"location":"API/wavefunction/stdl_wavefunction_/#c","title":"C","text":"<p>double* C</p> <p><code>double[nmo*nao]</code>, the LCAO coefficients matrix \\(C_{pq}\\).  Stored (from Gaussian) as <code>[c_mo0ao0, c_mo0ao1, ..., c_mo0aoN, c_mo1ao0, ..., c_moNaoN]</code>: the first index refers to the MO, the second to the AO.</p>"},{"location":"API/wavefunction/stdl_wavefunction_/#s","title":"S","text":"<p>double* S</p> <p><code>double[STDL_MATRIX_SP_SIZE(nao)]</code>, the overlap matrix \\(S_{\\mu\\nu}\\).</p>"},{"location":"API/wavefunction/stdl_wavefunction_/#aotoatm","title":"aotoatm","text":"<p>size_t* aotoatm</p> <p><code>size_t[nao]</code>, 0-based list of corresponding atom for each AO.</p>"},{"location":"API/wavefunction/stdl_wavefunction_/#atm","title":"atm","text":"<p>double* atm</p> <p><code>double[natm*4]</code>, list of atoms with nuclear charge (0) and coordinates (1:3)</p>"},{"location":"API/wavefunction/stdl_wavefunction_/#e","title":"e","text":"<p>double* e</p> <p><code>double[nmo]</code>, the MO energy vector \\(\\varepsilon_p\\) for each MO.</p>"},{"location":"API/wavefunction/stdl_wavefunction_/#nao","title":"nao","text":"<p>size_t nao</p> <p>Number of AO.</p>"},{"location":"API/wavefunction/stdl_wavefunction_/#natm","title":"natm","text":"<p>size_t natm</p> <p>Number of atoms</p>"},{"location":"API/wavefunction/stdl_wavefunction_/#nmo","title":"nmo","text":"<p>size_t nmo</p> <p>Number of MO. Should fulfill <code>nocc &lt;= nmo &lt;= nao</code>.</p>"},{"location":"API/wavefunction/stdl_wavefunction_/#nocc","title":"nocc","text":"<p>size_t nocc</p> <p>Number of occupied MO. Should be &gt;0.</p>"},{"location":"includes/API/","title":"API","text":""},{"location":"includes/API/#basic-principles","title":"Basic principles","text":"<ul> <li> <p>Unless otherwise mentioned, everything inputs and outputs are (to be) given in atomic units (of energy [hartree], of length [bohr], etc).</p> </li> <li> <p>Every object, enum, macro, or function that belongs to the public library API starts with <code>stdl_</code> (or <code>STDL_</code>).   Everything that does not is internal, and subject to change without notice.</p> </li> <li> <p>Every array is stored in the usual row major form rather than the usual in fortran, column major.</p> </li> <li> <p>The user is required delete all objects created within the library by using the provided deletor functions to avoid memory leaks.   Furthermore, each function return an error code (see logging and errors or <code>STDL_ERR_OK</code> if everything went well.   For example,</p> </li> </ul> <pre><code>#include &lt;stdlite/utils/base_parser.h&gt;\n\nint an_integer, error;\nstdl_lexer* lexer = NULL;\nFILE* f = open(\"tmp.txt\");\n\nif(f != NULL) {\n  if(stdl_lexer_new(&amp;lexer, f) == STDL_ERR_OK) {\n    if(stdl_parser_get_integer(lx, &amp;an_integer) == STDL_ERR_OK) {\n      printf(\"read: %d\\n\", an_integer);\n    }\n\n    stdl_lexer_delete(lexer); // deletor\n  }\n\n  fclose(f);\n}\n</code></pre> <ul> <li>Apart from the creator functions (<code>stdl_*_new()</code>) and stuffs that comes from files (FCHK or MOLDEN), the principle for outputs is \"bring-your-own-space\".    In other words, unless otherwise mentioned, outputs of functions (especially arrays) must have been allocated to their correct size.</li> </ul>"},{"location":"includes/API/#general-workflow","title":"General workflow","text":"<p>The general workflow to use <code>libstdlite</code> in order to compute a given property is the following:</p> <p></p>"},{"location":"includes/API/#specific-topics","title":"Specific topics","text":""},{"location":"includes/basis/","title":"Basis","text":"<p>Follows the structure of <code>libcint</code>, so that it can be used to compute extra integrals.</p> <p>Note</p> <p>Most of the documentation (and all examples) of libcint actually refers to the old (version &lt; 3.0) API. The new API actually includes two extra parameters described there. Furthermore, according to this, the first 20 values of <code>env</code> are reserved.</p> <p>Warning</p> <p>According to this comment, cartesian Gaussians are not (correctly) normalized by libcint. Thus every integral \\(\\braket{\\mu|\\hat A|\\nu}\\) between \\(\\mu\\) and \\(\\nu\\) (cartesian AOs) should be multiplied by a (re)normalization constant \\(N'_{\\mu\\nu} = N'_\\mu\\,N'_\\nu\\) with:</p> \\[N'_\\mu = \\frac{1}{\\sqrt{\\braket{\\mu|\\mu}}}.\\]"},{"location":"includes/experimental_quantity/","title":"Experimental quantity","text":""},{"location":"includes/experimental_quantity/#quantities-that-can-be-computed","title":"Quantities that can be computed","text":"<ul> <li> <p>Polarizability related quantities:</p> \\[\\bar{\\alpha}=\\frac{1}{3}\\sum_i^{xyz} \\alpha_{ii} \\text{ and } \\Delta\\alpha= \\left[\\frac{1}{2}\\sum_{ij}^{xyz} 3\\,\\alpha_{ij}^2 - \\alpha_{ii}\\,\\alpha_{jj}\\right]^{1/2},\\] <p>which are the iso- and anisotropic polarizability values, respectively.</p> </li> <li> <p>Hyper-Rayleigh Scattering (HRS) related quantities:</p> \\[\\begin{aligned} \\langle\\beta^2_{ZZZ}\\rangle &amp;= \\frac{1}{105}\\,\\sum_{ijk}^{xyz} 2\\,\\beta_{ijk}^2 + \\beta_{ijj} \\beta_{ikk} + 4\\, (\\beta_{iij} \\beta_{jkk} + \\beta_{iij} \\beta_{kjk} + \\beta_{ijk} \\beta_{jik}),\\\\ \\langle\\beta^2_{ZXX}\\rangle &amp;= \\frac{1}{105}\\, \\sum_{ijk}^{xyz} 6\\,\\beta_{ijk}^2 + 3\\,\\beta_{ijj} \\beta_{ikk} -2\\, (\\beta_{iij} \\beta_{jkk} +\\beta_{iij} \\beta_{kjk}  +\\beta_{ijk} \\beta_{jik}), \\end{aligned}\\] <p>which can then be used to compute \\(\\beta_{HRS}\\) and DR.</p> </li> </ul>"},{"location":"includes/fchk_parser/","title":"Fchk parser","text":"<p>While this parser contains a few safeguards, it works better if the FCHK is correctly formatted.</p> <p>Warning</p> <p>The logical type, <code>L</code>, is not implemented. However, it does not seem to be used in production FCHK. Scalar <code>C</code> is also not implemented nor used.</p> <p>The ordering of the orbitals for a given angular momentum is specific to Gaussian, but <code>stdlite</code> expects inputs and produce outputs following the order of <code>libcint</code>. The following transposition table is used for LCAO coefficients.</p> <p>For cartesian orbitals (<code>6d</code>, <code>10f</code>, <code>15g</code>, etc)</p> libcint (source) Gaussian (source) \\(s\\) \\(s\\) \\(p_x\\), \\(p_y\\), \\(p_z\\) \\(p_x\\), \\(p_y\\), \\(p_z\\) \\(d_{xx}\\) (0), \\(d_{xy}\\) (1), \\(d_{xz}\\) (2), \\(d_{yy}\\) (3), \\(d_{yz}\\) (4), \\(d_{zz}\\) (5) \\(d_{xx}\\) (0), \\(d_{yy}\\) (3), \\(d_{zz}\\) (5), \\(d_{xy}\\) (1), \\(d_{xz}\\) (2), \\(d_{yz}\\) (4) \\(f_{xxx}\\) (0), \\(f_{xxy}\\) (1), \\(f_{xxz}\\) (2), \\(f_{xyy}\\) (3), \\(f_{xyz}\\) (4), \\(f_{xzz}\\) (5), \\(f_{yyy}\\) (6), \\(f_{yyz}\\) (7), \\(f_{yzz}\\) (8), \\(f_{zzz}\\) (9) \\(f_{xxx}\\) (0), \\(f_{yyy}\\) (6), \\(f_{zzz}\\) (9), \\(f_{xyy}\\) (3), \\(f_{xxy}\\) (1), \\(f_{xxz}\\) (2), \\(f_{xzz}\\) (5), \\(f_{yzz}\\) (8), \\(f_{yyz}\\) (7), \\(f_{xyz}\\) (4) \\(g_{xxxx}\\) (0), \\(g_{xxxy}\\) (1), \\(g_{xxxz}\\) (2), \\(g_{xxyy}\\) (3), \\(g_{xxyz}\\) (4), \\(g_{xxzz}\\) (5), \\(g_{yyxz}\\) (6), \\(g_{yyyx}\\) (7), \\(g_{yyyy}\\) (8), \\(g_{yyyz}\\) (9), \\(g_{yyzz}\\) (10), \\(g_{zzxy}\\) (11), \\(g_{zzzx}\\) (12), \\(g_{zzzy}\\) (13), \\(g_{zzzz}\\) (14) \\(g_{xxxx}\\) (0), \\(g_{yyyy}\\) (8), \\(g_{zzzz}\\) (14), \\(g_{xxxy}\\) (1), \\(g_{xxxz}\\) (2), \\(g_{yyyx}\\) (7), \\(g_{yyyz}\\) (9), \\(g_{zzzx}\\) (12), \\(g_{zzzy}\\) (13), \\(g_{xxyy}\\) (3), \\(g_{xxzz}\\) (5), \\(g_{yyzz}\\) (10), \\(g_{xxyz}\\) (4), \\(g_{yyxz}\\) (6), \\(g_{zzxy}\\) (11) <p>For spherical orbitals (<code>5d</code>, <code>7f</code>, etc., see there for definition):</p> libcint (source) Gaussian (source) \\(d_{-2}\\) (0), \\(d_{-1}\\) (1), \\(d_0\\) (2), \\(d_1\\) (3), \\(d_2\\) (4) \\(d_0\\) (2), \\(d_1\\) (3), \\(d_{-1}\\) (1), \\(d_2\\) (4), \\(d_{-2}\\) (0) \\(f_{-3}\\) (0), \\(f_{-2}\\) (1), \\(f_{-1}\\) (2), \\(f_0\\) (3), \\(f_1\\) (4), \\(f_2\\) (5), \\(f_3\\) (6) \\(f_0\\) (3), \\(f_{1}\\) (4), \\(f_{-1}\\) (2), \\(f_{2}\\) (5), \\(f_{-2}\\) (1), \\(f_{3}\\) (6), \\(f_{-3}\\) (0) \\(g_{-4}\\) (0), \\(g_{-3}\\) (1), \\(g_{-2}\\) (2), \\(g_{-1}\\) (3), \\(g_0\\) (4), \\(g_1\\) (5), \\(g_2\\) (6), \\(g_3\\) (7), \\(g_4\\) (8) \\(g_0\\) (4), \\(g_1\\) (5), \\(g_{-1}\\) (3), \\(g_2\\) (6), \\(g_{-2}\\) (2), \\(g_3\\) (7), \\(g_{-3}\\) (1), \\(g_4\\) (8), \\(g_{-4}\\) (0) <p>Warning</p> <p>For the moment, only functions up to \\(g\\) are thus handled.</p> <p>In order to parse a FCHK, use something of the form:</p> <pre><code>char* name = NULL;\nchar type;\nint error, is_scalar;\n\n// 1. Open file, create lexer\nFILE* f = fopen(\"file.fchk\", \"r\");\nstdl_lexer* lx = stdl_lexer_new(f);\n\n// 2. Skip intro\nstdl_fchk_parser_skip_intro(lx);\n\n// 3. Read sections\nwhile (lx-&gt;current_tk_type != STDL_TK_EOF) {\n  // read section info, giving:\n  // a) the name of the section, b) its type, and c) if it is a scalar\n  error = stdl_fchk_parser_get_section_info(lx, &amp;name, &amp;type, &amp;is_scalar);\n\n  if(error == STDL_ERR_OK) {\n    if(strcmp(\"an interesting section\", name) == 0) {\n      /* Read the content of this section by using either:\n       * - `stdl_fchk_parser_get_scalar_*()`, or\n       * - `stdl_fchk_parser_get_vector_*()`.\n       * Don't forget to free the result after use.\n       */\n    } else if(/* ... */) {\n      /* ... */\n    } else {\n      // not interesting, skip section\n      stdl_fchk_parser_skip_section(lx, type, is_scalar);\n    }\n    free(name);\n  }\n}\n\nstdl_lexer_delete(lx);\nfclose(f);\n</code></pre>"},{"location":"includes/molden_parser/","title":"Molden parser","text":"<p>By default, cartesian orbitals are assumed, unless <code>[5D]</code> or <code>[5D7F]</code> is found. The ordering of the orbitals for a given angular momentum follows the one of Gaussian (see there).</p> <p>Warning</p> <p>Mixing of cartesian and spherical functions is not supported. Thus, <code>[5D10F]</code> and <code>[7F]</code> will result in an error.</p>"}]}